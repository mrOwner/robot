// Code generated by ogen, DO NOT EDIT.

package ogen

import (
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
)

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PortfolioRequestCurrencyRequest as json.
func (o OptPortfolioRequestCurrencyRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PortfolioRequestCurrencyRequest from json.
func (o *OptPortfolioRequestCurrencyRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPortfolioRequestCurrencyRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPortfolioRequestCurrencyRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPortfolioRequestCurrencyRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptStringInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeStringInt64(e, o.Value)
}

// Decode decodes int64 from json.
func (o *OptStringInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStringInt64 to nil")
	}
	o.Set = true
	v, err := json.DecodeStringInt64(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStringInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStringInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AccessLevel as json.
func (o OptV1AccessLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1AccessLevel from json.
func (o *OptV1AccessLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AccessLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AccountStatus as json.
func (o OptV1AccountStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1AccountStatus from json.
func (o *OptV1AccountStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AccountStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AccountStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AccountStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AccountType as json.
func (o OptV1AccountType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1AccountType from json.
func (o *OptV1AccountType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AccountType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AccountType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AccountType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetBond as json.
func (o OptV1AssetBond) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetBond from json.
func (o *OptV1AssetBond) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetBond to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetBond) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetBond) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetClearingCertificate as json.
func (o OptV1AssetClearingCertificate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetClearingCertificate from json.
func (o *OptV1AssetClearingCertificate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetClearingCertificate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetClearingCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetClearingCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetCurrency as json.
func (o OptV1AssetCurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetCurrency from json.
func (o *OptV1AssetCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetCurrency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetEtf as json.
func (o OptV1AssetEtf) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetEtf from json.
func (o *OptV1AssetEtf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetEtf to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetEtf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetEtf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetFull as json.
func (o OptV1AssetFull) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetFull from json.
func (o *OptV1AssetFull) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetFull to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetSecurity as json.
func (o OptV1AssetSecurity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetSecurity from json.
func (o *OptV1AssetSecurity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetSecurity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetShare as json.
func (o OptV1AssetShare) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetShare from json.
func (o *OptV1AssetShare) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetShare to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetShare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetShare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetStructuredProduct as json.
func (o OptV1AssetStructuredProduct) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1AssetStructuredProduct from json.
func (o *OptV1AssetStructuredProduct) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetStructuredProduct to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetStructuredProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetStructuredProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetType as json.
func (o OptV1AssetType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1AssetType from json.
func (o *OptV1AssetType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1AssetType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1AssetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1AssetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Bond as json.
func (o OptV1Bond) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Bond from json.
func (o *OptV1Bond) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Bond to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Bond) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Bond) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Brand as json.
func (o OptV1Brand) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Brand from json.
func (o *OptV1Brand) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Brand to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Brand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Brand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1CandleInterval as json.
func (o OptV1CandleInterval) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1CandleInterval from json.
func (o *OptV1CandleInterval) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1CandleInterval to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1CandleInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1CandleInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1CouponType as json.
func (o OptV1CouponType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1CouponType from json.
func (o *OptV1CouponType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1CouponType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1CouponType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1CouponType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Currency as json.
func (o OptV1Currency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Currency from json.
func (o *OptV1Currency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Currency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Currency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Currency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1EditFavoritesActionType as json.
func (o OptV1EditFavoritesActionType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1EditFavoritesActionType from json.
func (o *OptV1EditFavoritesActionType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1EditFavoritesActionType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1EditFavoritesActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1EditFavoritesActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Etf as json.
func (o OptV1Etf) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Etf from json.
func (o *OptV1Etf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Etf to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Etf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Etf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Future as json.
func (o OptV1Future) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Future from json.
func (o *OptV1Future) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Future to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Future) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Future) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GenerateBrokerReportRequest as json.
func (o OptV1GenerateBrokerReportRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GenerateBrokerReportRequest from json.
func (o *OptV1GenerateBrokerReportRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GenerateBrokerReportRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GenerateBrokerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GenerateBrokerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GenerateBrokerReportResponse as json.
func (o OptV1GenerateBrokerReportResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GenerateBrokerReportResponse from json.
func (o *OptV1GenerateBrokerReportResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GenerateBrokerReportResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GenerateBrokerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GenerateBrokerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GenerateDividendsForeignIssuerReportRequest as json.
func (o OptV1GenerateDividendsForeignIssuerReportRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GenerateDividendsForeignIssuerReportRequest from json.
func (o *OptV1GenerateDividendsForeignIssuerReportRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GenerateDividendsForeignIssuerReportRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GenerateDividendsForeignIssuerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GenerateDividendsForeignIssuerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GenerateDividendsForeignIssuerReportResponse as json.
func (o OptV1GenerateDividendsForeignIssuerReportResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GenerateDividendsForeignIssuerReportResponse from json.
func (o *OptV1GenerateDividendsForeignIssuerReportResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GenerateDividendsForeignIssuerReportResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GenerateDividendsForeignIssuerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GenerateDividendsForeignIssuerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GetBrokerReportRequest as json.
func (o OptV1GetBrokerReportRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GetBrokerReportRequest from json.
func (o *OptV1GetBrokerReportRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GetBrokerReportRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GetBrokerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GetBrokerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GetBrokerReportResponse as json.
func (o OptV1GetBrokerReportResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GetBrokerReportResponse from json.
func (o *OptV1GetBrokerReportResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GetBrokerReportResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GetBrokerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GetBrokerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GetDividendsForeignIssuerReportRequest as json.
func (o OptV1GetDividendsForeignIssuerReportRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GetDividendsForeignIssuerReportRequest from json.
func (o *OptV1GetDividendsForeignIssuerReportRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GetDividendsForeignIssuerReportRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GetDividendsForeignIssuerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GetDividendsForeignIssuerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1GetDividendsForeignIssuerReportResponse as json.
func (o OptV1GetDividendsForeignIssuerReportResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1GetDividendsForeignIssuerReportResponse from json.
func (o *OptV1GetDividendsForeignIssuerReportResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1GetDividendsForeignIssuerReportResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1GetDividendsForeignIssuerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1GetDividendsForeignIssuerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Instrument as json.
func (o OptV1Instrument) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Instrument from json.
func (o *OptV1Instrument) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Instrument to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Instrument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Instrument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1InstrumentIdType as json.
func (o OptV1InstrumentIdType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1InstrumentIdType from json.
func (o *OptV1InstrumentIdType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1InstrumentIdType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1InstrumentIdType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1InstrumentIdType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1InstrumentStatus as json.
func (o OptV1InstrumentStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1InstrumentStatus from json.
func (o *OptV1InstrumentStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1InstrumentStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1InstrumentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1InstrumentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1InstrumentType as json.
func (o OptV1InstrumentType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1InstrumentType from json.
func (o *OptV1InstrumentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1InstrumentType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1InstrumentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1InstrumentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1MoneyValue as json.
func (o OptV1MoneyValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1MoneyValue from json.
func (o *OptV1MoneyValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1MoneyValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1MoneyValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1MoneyValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OperationItemTrades as json.
func (o OptV1OperationItemTrades) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1OperationItemTrades from json.
func (o *OptV1OperationItemTrades) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OperationItemTrades to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OperationItemTrades) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OperationItemTrades) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OperationState as json.
func (o OptV1OperationState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OperationState from json.
func (o *OptV1OperationState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OperationState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OperationState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OperationState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OperationType as json.
func (o OptV1OperationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OperationType from json.
func (o *OptV1OperationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OperationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OperationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OperationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Option as json.
func (o OptV1Option) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Option from json.
func (o *OptV1Option) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Option to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Option) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Option) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionDirection as json.
func (o OptV1OptionDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OptionDirection from json.
func (o *OptV1OptionDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OptionDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OptionDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OptionDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionPaymentType as json.
func (o OptV1OptionPaymentType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OptionPaymentType from json.
func (o *OptV1OptionPaymentType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OptionPaymentType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OptionPaymentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OptionPaymentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionSettlementType as json.
func (o OptV1OptionSettlementType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OptionSettlementType from json.
func (o *OptV1OptionSettlementType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OptionSettlementType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OptionSettlementType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OptionSettlementType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionStyle as json.
func (o OptV1OptionStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OptionStyle from json.
func (o *OptV1OptionStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OptionStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OptionStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OptionStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OrderDirection as json.
func (o OptV1OrderDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OrderDirection from json.
func (o *OptV1OrderDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OrderDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OrderDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OrderDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OrderExecutionReportStatus as json.
func (o OptV1OrderExecutionReportStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OrderExecutionReportStatus from json.
func (o *OptV1OrderExecutionReportStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OrderExecutionReportStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OrderExecutionReportStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OrderExecutionReportStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OrderType as json.
func (o OptV1OrderType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1OrderType from json.
func (o *OptV1OrderType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1OrderType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1OrderType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1OrderType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1PriceType as json.
func (o OptV1PriceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1PriceType from json.
func (o *OptV1PriceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1PriceType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1PriceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1PriceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Quotation as json.
func (o OptV1Quotation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Quotation from json.
func (o *OptV1Quotation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Quotation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Quotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Quotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1RealExchange as json.
func (o OptV1RealExchange) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1RealExchange from json.
func (o *OptV1RealExchange) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1RealExchange to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1RealExchange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1RealExchange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1RiskLevel as json.
func (o OptV1RiskLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1RiskLevel from json.
func (o *OptV1RiskLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1RiskLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1RiskLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1RiskLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1SecurityTradingStatus as json.
func (o OptV1SecurityTradingStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1SecurityTradingStatus from json.
func (o *OptV1SecurityTradingStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1SecurityTradingStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1SecurityTradingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1SecurityTradingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1Share as json.
func (o OptV1Share) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes V1Share from json.
func (o *OptV1Share) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1Share to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1Share) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1Share) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1ShareType as json.
func (o OptV1ShareType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1ShareType from json.
func (o *OptV1ShareType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1ShareType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1ShareType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1ShareType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StopOrderDirection as json.
func (o OptV1StopOrderDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1StopOrderDirection from json.
func (o *OptV1StopOrderDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1StopOrderDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1StopOrderDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1StopOrderDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StopOrderExpirationType as json.
func (o OptV1StopOrderExpirationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1StopOrderExpirationType from json.
func (o *OptV1StopOrderExpirationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1StopOrderExpirationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1StopOrderExpirationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1StopOrderExpirationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StopOrderType as json.
func (o OptV1StopOrderType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1StopOrderType from json.
func (o *OptV1StopOrderType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1StopOrderType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1StopOrderType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1StopOrderType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StructuredProductType as json.
func (o OptV1StructuredProductType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1StructuredProductType from json.
func (o *OptV1StructuredProductType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1StructuredProductType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1StructuredProductType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1StructuredProductType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1TradeDirection as json.
func (o OptV1TradeDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes V1TradeDirection from json.
func (o *OptV1TradeDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptV1TradeDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptV1TradeDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptV1TradeDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PortfolioRequestCurrencyRequest as json.
func (s PortfolioRequestCurrencyRequest) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PortfolioRequestCurrencyRequest from json.
func (s *PortfolioRequestCurrencyRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortfolioRequestCurrencyRequest to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PortfolioRequestCurrencyRequest(v) {
	case PortfolioRequestCurrencyRequestRUB:
		*s = PortfolioRequestCurrencyRequestRUB
	case PortfolioRequestCurrencyRequestUSD:
		*s = PortfolioRequestCurrencyRequestUSD
	case PortfolioRequestCurrencyRequestEUR:
		*s = PortfolioRequestCurrencyRequestEUR
	default:
		*s = PortfolioRequestCurrencyRequest(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PortfolioRequestCurrencyRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortfolioRequestCurrencyRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProtobufAny) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProtobufAny) encodeFields(e *jx.Encoder) {
	{
		if s.TypeUrl.Set {
			e.FieldStart("typeUrl")
			s.TypeUrl.Encode(e)
		}
	}
	{

		e.FieldStart("value")
		e.Base64(s.Value)
	}
}

var jsonFieldsNameOfProtobufAny = [2]string{
	0: "typeUrl",
	1: "value",
}

// Decode decodes ProtobufAny from json.
func (s *ProtobufAny) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProtobufAny to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "typeUrl":
			if err := func() error {
				s.TypeUrl.Reset()
				if err := s.TypeUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typeUrl\"")
			}
		case "value":
			if err := func() error {
				v, err := d.Base64()
				s.Value = []byte(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProtobufAny")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProtobufAny) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProtobufAny) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RpcStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RpcStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			e.ArrStart()
			for _, elem := range s.Details {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRpcStatus = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes RpcStatus from json.
func (s *RpcStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RpcStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details = make([]ProtobufAny, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProtobufAny
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Details = append(s.Details, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RpcStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RpcStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RpcStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AccessLevel as json.
func (s V1AccessLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1AccessLevel from json.
func (s *V1AccessLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AccessLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1AccessLevel(v) {
	case V1AccessLevelACCOUNTACCESSLEVELUNSPECIFIED:
		*s = V1AccessLevelACCOUNTACCESSLEVELUNSPECIFIED
	case V1AccessLevelACCOUNTACCESSLEVELFULLACCESS:
		*s = V1AccessLevelACCOUNTACCESSLEVELFULLACCESS
	case V1AccessLevelACCOUNTACCESSLEVELREADONLY:
		*s = V1AccessLevelACCOUNTACCESSLEVELREADONLY
	case V1AccessLevelACCOUNTACCESSLEVELNOACCESS:
		*s = V1AccessLevelACCOUNTACCESSLEVELNOACCESS
	default:
		*s = V1AccessLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1AccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Account) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Account) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.OpenedDate.Set {
			e.FieldStart("openedDate")
			s.OpenedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ClosedDate.Set {
			e.FieldStart("closedDate")
			s.ClosedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AccessLevel.Set {
			e.FieldStart("accessLevel")
			s.AccessLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Account = [7]string{
	0: "id",
	1: "type",
	2: "name",
	3: "status",
	4: "openedDate",
	5: "closedDate",
	6: "accessLevel",
}

// Decode decodes V1Account from json.
func (s *V1Account) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Account to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "openedDate":
			if err := func() error {
				s.OpenedDate.Reset()
				if err := s.OpenedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openedDate\"")
			}
		case "closedDate":
			if err := func() error {
				s.ClosedDate.Reset()
				if err := s.ClosedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closedDate\"")
			}
		case "accessLevel":
			if err := func() error {
				s.AccessLevel.Reset()
				if err := s.AccessLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessLevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Account")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Account) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Account) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AccountStatus as json.
func (s V1AccountStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1AccountStatus from json.
func (s *V1AccountStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AccountStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1AccountStatus(v) {
	case V1AccountStatusACCOUNTSTATUSUNSPECIFIED:
		*s = V1AccountStatusACCOUNTSTATUSUNSPECIFIED
	case V1AccountStatusACCOUNTSTATUSNEW:
		*s = V1AccountStatusACCOUNTSTATUSNEW
	case V1AccountStatusACCOUNTSTATUSOPEN:
		*s = V1AccountStatusACCOUNTSTATUSOPEN
	case V1AccountStatusACCOUNTSTATUSCLOSED:
		*s = V1AccountStatusACCOUNTSTATUSCLOSED
	default:
		*s = V1AccountStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1AccountStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AccountStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AccountType as json.
func (s V1AccountType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1AccountType from json.
func (s *V1AccountType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AccountType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1AccountType(v) {
	case V1AccountTypeACCOUNTTYPEUNSPECIFIED:
		*s = V1AccountTypeACCOUNTTYPEUNSPECIFIED
	case V1AccountTypeACCOUNTTYPETINKOFF:
		*s = V1AccountTypeACCOUNTTYPETINKOFF
	case V1AccountTypeACCOUNTTYPETINKOFFIIS:
		*s = V1AccountTypeACCOUNTTYPETINKOFFIIS
	case V1AccountTypeACCOUNTTYPEINVESTBOX:
		*s = V1AccountTypeACCOUNTTYPEINVESTBOX
	default:
		*s = V1AccountType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1AccountType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AccountType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AccruedInterest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AccruedInterest) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.ValuePercent.Set {
			e.FieldStart("valuePercent")
			s.ValuePercent.Encode(e)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AccruedInterest = [4]string{
	0: "date",
	1: "value",
	2: "valuePercent",
	3: "nominal",
}

// Decode decodes V1AccruedInterest from json.
func (s *V1AccruedInterest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AccruedInterest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "valuePercent":
			if err := func() error {
				s.ValuePercent.Reset()
				if err := s.ValuePercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valuePercent\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AccruedInterest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AccruedInterest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AccruedInterest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Asset) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Asset) encodeFields(e *jx.Encoder) {
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1Asset = [4]string{
	0: "uid",
	1: "type",
	2: "name",
	3: "instruments",
}

// Decode decodes V1Asset from json.
func (s *V1Asset) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Asset to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1AssetInstrument, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1AssetInstrument
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Asset")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Asset) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Asset) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetBond) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetBond) encodeFields(e *jx.Encoder) {
	{
		if s.CurrentNominal.Set {
			e.FieldStart("currentNominal")
			s.CurrentNominal.Encode(e)
		}
	}
	{
		if s.BorrowName.Set {
			e.FieldStart("borrowName")
			s.BorrowName.Encode(e)
		}
	}
	{
		if s.IssueSize.Set {
			e.FieldStart("issueSize")
			s.IssueSize.Encode(e)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.NominalCurrency.Set {
			e.FieldStart("nominalCurrency")
			s.NominalCurrency.Encode(e)
		}
	}
	{
		if s.IssueKind.Set {
			e.FieldStart("issueKind")
			s.IssueKind.Encode(e)
		}
	}
	{
		if s.InterestKind.Set {
			e.FieldStart("interestKind")
			s.InterestKind.Encode(e)
		}
	}
	{
		if s.CouponQuantityPerYear.Set {
			e.FieldStart("couponQuantityPerYear")
			s.CouponQuantityPerYear.Encode(e)
		}
	}
	{
		if s.IndexedNominalFlag.Set {
			e.FieldStart("indexedNominalFlag")
			s.IndexedNominalFlag.Encode(e)
		}
	}
	{
		if s.SubordinatedFlag.Set {
			e.FieldStart("subordinatedFlag")
			s.SubordinatedFlag.Encode(e)
		}
	}
	{
		if s.CollateralFlag.Set {
			e.FieldStart("collateralFlag")
			s.CollateralFlag.Encode(e)
		}
	}
	{
		if s.TaxFreeFlag.Set {
			e.FieldStart("taxFreeFlag")
			s.TaxFreeFlag.Encode(e)
		}
	}
	{
		if s.AmortizationFlag.Set {
			e.FieldStart("amortizationFlag")
			s.AmortizationFlag.Encode(e)
		}
	}
	{
		if s.FloatingCouponFlag.Set {
			e.FieldStart("floatingCouponFlag")
			s.FloatingCouponFlag.Encode(e)
		}
	}
	{
		if s.PerpetualFlag.Set {
			e.FieldStart("perpetualFlag")
			s.PerpetualFlag.Encode(e)
		}
	}
	{
		if s.MaturityDate.Set {
			e.FieldStart("maturityDate")
			s.MaturityDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ReturnCondition.Set {
			e.FieldStart("returnCondition")
			s.ReturnCondition.Encode(e)
		}
	}
	{
		if s.StateRegDate.Set {
			e.FieldStart("stateRegDate")
			s.StateRegDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PlacementDate.Set {
			e.FieldStart("placementDate")
			s.PlacementDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PlacementPrice.Set {
			e.FieldStart("placementPrice")
			s.PlacementPrice.Encode(e)
		}
	}
	{
		if s.IssueSizePlan.Set {
			e.FieldStart("issueSizePlan")
			s.IssueSizePlan.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetBond = [21]string{
	0:  "currentNominal",
	1:  "borrowName",
	2:  "issueSize",
	3:  "nominal",
	4:  "nominalCurrency",
	5:  "issueKind",
	6:  "interestKind",
	7:  "couponQuantityPerYear",
	8:  "indexedNominalFlag",
	9:  "subordinatedFlag",
	10: "collateralFlag",
	11: "taxFreeFlag",
	12: "amortizationFlag",
	13: "floatingCouponFlag",
	14: "perpetualFlag",
	15: "maturityDate",
	16: "returnCondition",
	17: "stateRegDate",
	18: "placementDate",
	19: "placementPrice",
	20: "issueSizePlan",
}

// Decode decodes V1AssetBond from json.
func (s *V1AssetBond) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetBond to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentNominal":
			if err := func() error {
				s.CurrentNominal.Reset()
				if err := s.CurrentNominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentNominal\"")
			}
		case "borrowName":
			if err := func() error {
				s.BorrowName.Reset()
				if err := s.BorrowName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"borrowName\"")
			}
		case "issueSize":
			if err := func() error {
				s.IssueSize.Reset()
				if err := s.IssueSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSize\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "nominalCurrency":
			if err := func() error {
				s.NominalCurrency.Reset()
				if err := s.NominalCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominalCurrency\"")
			}
		case "issueKind":
			if err := func() error {
				s.IssueKind.Reset()
				if err := s.IssueKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueKind\"")
			}
		case "interestKind":
			if err := func() error {
				s.InterestKind.Reset()
				if err := s.InterestKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interestKind\"")
			}
		case "couponQuantityPerYear":
			if err := func() error {
				s.CouponQuantityPerYear.Reset()
				if err := s.CouponQuantityPerYear.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponQuantityPerYear\"")
			}
		case "indexedNominalFlag":
			if err := func() error {
				s.IndexedNominalFlag.Reset()
				if err := s.IndexedNominalFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexedNominalFlag\"")
			}
		case "subordinatedFlag":
			if err := func() error {
				s.SubordinatedFlag.Reset()
				if err := s.SubordinatedFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subordinatedFlag\"")
			}
		case "collateralFlag":
			if err := func() error {
				s.CollateralFlag.Reset()
				if err := s.CollateralFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collateralFlag\"")
			}
		case "taxFreeFlag":
			if err := func() error {
				s.TaxFreeFlag.Reset()
				if err := s.TaxFreeFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taxFreeFlag\"")
			}
		case "amortizationFlag":
			if err := func() error {
				s.AmortizationFlag.Reset()
				if err := s.AmortizationFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amortizationFlag\"")
			}
		case "floatingCouponFlag":
			if err := func() error {
				s.FloatingCouponFlag.Reset()
				if err := s.FloatingCouponFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"floatingCouponFlag\"")
			}
		case "perpetualFlag":
			if err := func() error {
				s.PerpetualFlag.Reset()
				if err := s.PerpetualFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perpetualFlag\"")
			}
		case "maturityDate":
			if err := func() error {
				s.MaturityDate.Reset()
				if err := s.MaturityDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maturityDate\"")
			}
		case "returnCondition":
			if err := func() error {
				s.ReturnCondition.Reset()
				if err := s.ReturnCondition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"returnCondition\"")
			}
		case "stateRegDate":
			if err := func() error {
				s.StateRegDate.Reset()
				if err := s.StateRegDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stateRegDate\"")
			}
		case "placementDate":
			if err := func() error {
				s.PlacementDate.Reset()
				if err := s.PlacementDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placementDate\"")
			}
		case "placementPrice":
			if err := func() error {
				s.PlacementPrice.Reset()
				if err := s.PlacementPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placementPrice\"")
			}
		case "issueSizePlan":
			if err := func() error {
				s.IssueSizePlan.Reset()
				if err := s.IssueSizePlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSizePlan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetBond")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetBond) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetBond) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetClearingCertificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetClearingCertificate) encodeFields(e *jx.Encoder) {
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.NominalCurrency.Set {
			e.FieldStart("nominalCurrency")
			s.NominalCurrency.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetClearingCertificate = [2]string{
	0: "nominal",
	1: "nominalCurrency",
}

// Decode decodes V1AssetClearingCertificate from json.
func (s *V1AssetClearingCertificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetClearingCertificate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "nominalCurrency":
			if err := func() error {
				s.NominalCurrency.Reset()
				if err := s.NominalCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominalCurrency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetClearingCertificate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetClearingCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetClearingCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetCurrency) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetCurrency) encodeFields(e *jx.Encoder) {
	{
		if s.BaseCurrency.Set {
			e.FieldStart("baseCurrency")
			s.BaseCurrency.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetCurrency = [1]string{
	0: "baseCurrency",
}

// Decode decodes V1AssetCurrency from json.
func (s *V1AssetCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetCurrency to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "baseCurrency":
			if err := func() error {
				s.BaseCurrency.Reset()
				if err := s.BaseCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baseCurrency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetCurrency")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetEtf) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetEtf) encodeFields(e *jx.Encoder) {
	{
		if s.TotalExpense.Set {
			e.FieldStart("totalExpense")
			s.TotalExpense.Encode(e)
		}
	}
	{
		if s.HurdleRate.Set {
			e.FieldStart("hurdleRate")
			s.HurdleRate.Encode(e)
		}
	}
	{
		if s.PerformanceFee.Set {
			e.FieldStart("performanceFee")
			s.PerformanceFee.Encode(e)
		}
	}
	{
		if s.FixedCommission.Set {
			e.FieldStart("fixedCommission")
			s.FixedCommission.Encode(e)
		}
	}
	{
		if s.PaymentType.Set {
			e.FieldStart("paymentType")
			s.PaymentType.Encode(e)
		}
	}
	{
		if s.WatermarkFlag.Set {
			e.FieldStart("watermarkFlag")
			s.WatermarkFlag.Encode(e)
		}
	}
	{
		if s.BuyPremium.Set {
			e.FieldStart("buyPremium")
			s.BuyPremium.Encode(e)
		}
	}
	{
		if s.SellDiscount.Set {
			e.FieldStart("sellDiscount")
			s.SellDiscount.Encode(e)
		}
	}
	{
		if s.RebalancingFlag.Set {
			e.FieldStart("rebalancingFlag")
			s.RebalancingFlag.Encode(e)
		}
	}
	{
		if s.RebalancingFreq.Set {
			e.FieldStart("rebalancingFreq")
			s.RebalancingFreq.Encode(e)
		}
	}
	{
		if s.ManagementType.Set {
			e.FieldStart("managementType")
			s.ManagementType.Encode(e)
		}
	}
	{
		if s.PrimaryIndex.Set {
			e.FieldStart("primaryIndex")
			s.PrimaryIndex.Encode(e)
		}
	}
	{
		if s.FocusType.Set {
			e.FieldStart("focusType")
			s.FocusType.Encode(e)
		}
	}
	{
		if s.LeveragedFlag.Set {
			e.FieldStart("leveragedFlag")
			s.LeveragedFlag.Encode(e)
		}
	}
	{
		if s.NumShare.Set {
			e.FieldStart("numShare")
			s.NumShare.Encode(e)
		}
	}
	{
		if s.UcitsFlag.Set {
			e.FieldStart("ucitsFlag")
			s.UcitsFlag.Encode(e)
		}
	}
	{
		if s.ReleasedDate.Set {
			e.FieldStart("releasedDate")
			s.ReleasedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.PrimaryIndexDescription.Set {
			e.FieldStart("primaryIndexDescription")
			s.PrimaryIndexDescription.Encode(e)
		}
	}
	{
		if s.PrimaryIndexCompany.Set {
			e.FieldStart("primaryIndexCompany")
			s.PrimaryIndexCompany.Encode(e)
		}
	}
	{
		if s.IndexRecoveryPeriod.Set {
			e.FieldStart("indexRecoveryPeriod")
			s.IndexRecoveryPeriod.Encode(e)
		}
	}
	{
		if s.InavCode.Set {
			e.FieldStart("inavCode")
			s.InavCode.Encode(e)
		}
	}
	{
		if s.DivYieldFlag.Set {
			e.FieldStart("divYieldFlag")
			s.DivYieldFlag.Encode(e)
		}
	}
	{
		if s.ExpenseCommission.Set {
			e.FieldStart("expenseCommission")
			s.ExpenseCommission.Encode(e)
		}
	}
	{
		if s.PrimaryIndexTrackingError.Set {
			e.FieldStart("primaryIndexTrackingError")
			s.PrimaryIndexTrackingError.Encode(e)
		}
	}
	{
		if s.RebalancingPlan.Set {
			e.FieldStart("rebalancingPlan")
			s.RebalancingPlan.Encode(e)
		}
	}
	{
		if s.TaxRate.Set {
			e.FieldStart("taxRate")
			s.TaxRate.Encode(e)
		}
	}
	{
		if s.RebalancingDates != nil {
			e.FieldStart("rebalancingDates")
			e.ArrStart()
			for _, elem := range s.RebalancingDates {
				json.EncodeDateTime(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IssueKind.Set {
			e.FieldStart("issueKind")
			s.IssueKind.Encode(e)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.NominalCurrency.Set {
			e.FieldStart("nominalCurrency")
			s.NominalCurrency.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetEtf = [31]string{
	0:  "totalExpense",
	1:  "hurdleRate",
	2:  "performanceFee",
	3:  "fixedCommission",
	4:  "paymentType",
	5:  "watermarkFlag",
	6:  "buyPremium",
	7:  "sellDiscount",
	8:  "rebalancingFlag",
	9:  "rebalancingFreq",
	10: "managementType",
	11: "primaryIndex",
	12: "focusType",
	13: "leveragedFlag",
	14: "numShare",
	15: "ucitsFlag",
	16: "releasedDate",
	17: "description",
	18: "primaryIndexDescription",
	19: "primaryIndexCompany",
	20: "indexRecoveryPeriod",
	21: "inavCode",
	22: "divYieldFlag",
	23: "expenseCommission",
	24: "primaryIndexTrackingError",
	25: "rebalancingPlan",
	26: "taxRate",
	27: "rebalancingDates",
	28: "issueKind",
	29: "nominal",
	30: "nominalCurrency",
}

// Decode decodes V1AssetEtf from json.
func (s *V1AssetEtf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetEtf to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalExpense":
			if err := func() error {
				s.TotalExpense.Reset()
				if err := s.TotalExpense.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalExpense\"")
			}
		case "hurdleRate":
			if err := func() error {
				s.HurdleRate.Reset()
				if err := s.HurdleRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hurdleRate\"")
			}
		case "performanceFee":
			if err := func() error {
				s.PerformanceFee.Reset()
				if err := s.PerformanceFee.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"performanceFee\"")
			}
		case "fixedCommission":
			if err := func() error {
				s.FixedCommission.Reset()
				if err := s.FixedCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fixedCommission\"")
			}
		case "paymentType":
			if err := func() error {
				s.PaymentType.Reset()
				if err := s.PaymentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paymentType\"")
			}
		case "watermarkFlag":
			if err := func() error {
				s.WatermarkFlag.Reset()
				if err := s.WatermarkFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watermarkFlag\"")
			}
		case "buyPremium":
			if err := func() error {
				s.BuyPremium.Reset()
				if err := s.BuyPremium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyPremium\"")
			}
		case "sellDiscount":
			if err := func() error {
				s.SellDiscount.Reset()
				if err := s.SellDiscount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellDiscount\"")
			}
		case "rebalancingFlag":
			if err := func() error {
				s.RebalancingFlag.Reset()
				if err := s.RebalancingFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalancingFlag\"")
			}
		case "rebalancingFreq":
			if err := func() error {
				s.RebalancingFreq.Reset()
				if err := s.RebalancingFreq.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalancingFreq\"")
			}
		case "managementType":
			if err := func() error {
				s.ManagementType.Reset()
				if err := s.ManagementType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"managementType\"")
			}
		case "primaryIndex":
			if err := func() error {
				s.PrimaryIndex.Reset()
				if err := s.PrimaryIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryIndex\"")
			}
		case "focusType":
			if err := func() error {
				s.FocusType.Reset()
				if err := s.FocusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"focusType\"")
			}
		case "leveragedFlag":
			if err := func() error {
				s.LeveragedFlag.Reset()
				if err := s.LeveragedFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leveragedFlag\"")
			}
		case "numShare":
			if err := func() error {
				s.NumShare.Reset()
				if err := s.NumShare.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numShare\"")
			}
		case "ucitsFlag":
			if err := func() error {
				s.UcitsFlag.Reset()
				if err := s.UcitsFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ucitsFlag\"")
			}
		case "releasedDate":
			if err := func() error {
				s.ReleasedDate.Reset()
				if err := s.ReleasedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releasedDate\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "primaryIndexDescription":
			if err := func() error {
				s.PrimaryIndexDescription.Reset()
				if err := s.PrimaryIndexDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryIndexDescription\"")
			}
		case "primaryIndexCompany":
			if err := func() error {
				s.PrimaryIndexCompany.Reset()
				if err := s.PrimaryIndexCompany.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryIndexCompany\"")
			}
		case "indexRecoveryPeriod":
			if err := func() error {
				s.IndexRecoveryPeriod.Reset()
				if err := s.IndexRecoveryPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexRecoveryPeriod\"")
			}
		case "inavCode":
			if err := func() error {
				s.InavCode.Reset()
				if err := s.InavCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inavCode\"")
			}
		case "divYieldFlag":
			if err := func() error {
				s.DivYieldFlag.Reset()
				if err := s.DivYieldFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"divYieldFlag\"")
			}
		case "expenseCommission":
			if err := func() error {
				s.ExpenseCommission.Reset()
				if err := s.ExpenseCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expenseCommission\"")
			}
		case "primaryIndexTrackingError":
			if err := func() error {
				s.PrimaryIndexTrackingError.Reset()
				if err := s.PrimaryIndexTrackingError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryIndexTrackingError\"")
			}
		case "rebalancingPlan":
			if err := func() error {
				s.RebalancingPlan.Reset()
				if err := s.RebalancingPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalancingPlan\"")
			}
		case "taxRate":
			if err := func() error {
				s.TaxRate.Reset()
				if err := s.TaxRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taxRate\"")
			}
		case "rebalancingDates":
			if err := func() error {
				s.RebalancingDates = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem time.Time
					v, err := json.DecodeDateTime(d)
					elem = v
					if err != nil {
						return err
					}
					s.RebalancingDates = append(s.RebalancingDates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalancingDates\"")
			}
		case "issueKind":
			if err := func() error {
				s.IssueKind.Reset()
				if err := s.IssueKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueKind\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "nominalCurrency":
			if err := func() error {
				s.NominalCurrency.Reset()
				if err := s.NominalCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominalCurrency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetEtf")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetEtf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetEtf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetFull) encodeFields(e *jx.Encoder) {
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NameBrief.Set {
			e.FieldStart("nameBrief")
			s.NameBrief.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deletedAt")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RequiredTests != nil {
			e.FieldStart("requiredTests")
			e.ArrStart()
			for _, elem := range s.RequiredTests {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Security.Set {
			e.FieldStart("security")
			s.Security.Encode(e)
		}
	}
	{
		if s.GosRegCode.Set {
			e.FieldStart("gosRegCode")
			s.GosRegCode.Encode(e)
		}
	}
	{
		if s.Cfi.Set {
			e.FieldStart("cfi")
			s.Cfi.Encode(e)
		}
	}
	{
		if s.CodeNsd.Set {
			e.FieldStart("codeNsd")
			s.CodeNsd.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Brand.Set {
			e.FieldStart("brand")
			s.Brand.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BrCode.Set {
			e.FieldStart("brCode")
			s.BrCode.Encode(e)
		}
	}
	{
		if s.BrCodeName.Set {
			e.FieldStart("brCodeName")
			s.BrCodeName.Encode(e)
		}
	}
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1AssetFull = [18]string{
	0:  "uid",
	1:  "type",
	2:  "name",
	3:  "nameBrief",
	4:  "description",
	5:  "deletedAt",
	6:  "requiredTests",
	7:  "currency",
	8:  "security",
	9:  "gosRegCode",
	10: "cfi",
	11: "codeNsd",
	12: "status",
	13: "brand",
	14: "updatedAt",
	15: "brCode",
	16: "brCodeName",
	17: "instruments",
}

// Decode decodes V1AssetFull from json.
func (s *V1AssetFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetFull to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nameBrief":
			if err := func() error {
				s.NameBrief.Reset()
				if err := s.NameBrief.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameBrief\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "deletedAt":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "requiredTests":
			if err := func() error {
				s.RequiredTests = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RequiredTests = append(s.RequiredTests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredTests\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "security":
			if err := func() error {
				s.Security.Reset()
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "gosRegCode":
			if err := func() error {
				s.GosRegCode.Reset()
				if err := s.GosRegCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gosRegCode\"")
			}
		case "cfi":
			if err := func() error {
				s.Cfi.Reset()
				if err := s.Cfi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cfi\"")
			}
		case "codeNsd":
			if err := func() error {
				s.CodeNsd.Reset()
				if err := s.CodeNsd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"codeNsd\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "brand":
			if err := func() error {
				s.Brand.Reset()
				if err := s.Brand.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brand\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "brCode":
			if err := func() error {
				s.BrCode.Reset()
				if err := s.BrCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brCode\"")
			}
		case "brCodeName":
			if err := func() error {
				s.BrCodeName.Reset()
				if err := s.BrCodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brCodeName\"")
			}
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1AssetInstrument, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1AssetInstrument
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetFull")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetInstrument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetInstrument) encodeFields(e *jx.Encoder) {
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Links != nil {
			e.FieldStart("links")
			e.ArrStart()
			for _, elem := range s.Links {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InstrumentKind.Set {
			e.FieldStart("instrumentKind")
			s.InstrumentKind.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetInstrument = [7]string{
	0: "uid",
	1: "figi",
	2: "instrumentType",
	3: "ticker",
	4: "classCode",
	5: "links",
	6: "instrumentKind",
}

// Decode decodes V1AssetInstrument from json.
func (s *V1AssetInstrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetInstrument to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "links":
			if err := func() error {
				s.Links = make([]V1InstrumentLink, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1InstrumentLink
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "instrumentKind":
			if err := func() error {
				s.InstrumentKind.Reset()
				if err := s.InstrumentKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentKind\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetInstrument")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetInstrument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetInstrument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetRequest = [1]string{
	0: "id",
}

// Decode decodes V1AssetRequest from json.
func (s *V1AssetRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Asset.Set {
			e.FieldStart("asset")
			s.Asset.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetResponse = [1]string{
	0: "asset",
}

// Decode decodes V1AssetResponse from json.
func (s *V1AssetResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "asset":
			if err := func() error {
				s.Asset.Reset()
				if err := s.Asset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetSecurity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetSecurity) encodeFields(e *jx.Encoder) {
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.InstrumentKind.Set {
			e.FieldStart("instrumentKind")
			s.InstrumentKind.Encode(e)
		}
	}
	{
		if s.Share.Set {
			e.FieldStart("share")
			s.Share.Encode(e)
		}
	}
	{
		if s.Bond.Set {
			e.FieldStart("bond")
			s.Bond.Encode(e)
		}
	}
	{
		if s.Sp.Set {
			e.FieldStart("sp")
			s.Sp.Encode(e)
		}
	}
	{
		if s.Etf.Set {
			e.FieldStart("etf")
			s.Etf.Encode(e)
		}
	}
	{
		if s.ClearingCertificate.Set {
			e.FieldStart("clearingCertificate")
			s.ClearingCertificate.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetSecurity = [8]string{
	0: "isin",
	1: "type",
	2: "instrumentKind",
	3: "share",
	4: "bond",
	5: "sp",
	6: "etf",
	7: "clearingCertificate",
}

// Decode decodes V1AssetSecurity from json.
func (s *V1AssetSecurity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetSecurity to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "instrumentKind":
			if err := func() error {
				s.InstrumentKind.Reset()
				if err := s.InstrumentKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentKind\"")
			}
		case "share":
			if err := func() error {
				s.Share.Reset()
				if err := s.Share.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"share\"")
			}
		case "bond":
			if err := func() error {
				s.Bond.Reset()
				if err := s.Bond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bond\"")
			}
		case "sp":
			if err := func() error {
				s.Sp.Reset()
				if err := s.Sp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sp\"")
			}
		case "etf":
			if err := func() error {
				s.Etf.Reset()
				if err := s.Etf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"etf\"")
			}
		case "clearingCertificate":
			if err := func() error {
				s.ClearingCertificate.Reset()
				if err := s.ClearingCertificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clearingCertificate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetSecurity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetSecurity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetSecurity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetShare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetShare) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.IssueSize.Set {
			e.FieldStart("issueSize")
			s.IssueSize.Encode(e)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.NominalCurrency.Set {
			e.FieldStart("nominalCurrency")
			s.NominalCurrency.Encode(e)
		}
	}
	{
		if s.PrimaryIndex.Set {
			e.FieldStart("primaryIndex")
			s.PrimaryIndex.Encode(e)
		}
	}
	{
		if s.DividendRate.Set {
			e.FieldStart("dividendRate")
			s.DividendRate.Encode(e)
		}
	}
	{
		if s.PreferredShareType.Set {
			e.FieldStart("preferredShareType")
			s.PreferredShareType.Encode(e)
		}
	}
	{
		if s.IpoDate.Set {
			e.FieldStart("ipoDate")
			s.IpoDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RegistryDate.Set {
			e.FieldStart("registryDate")
			s.RegistryDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DivYieldFlag.Set {
			e.FieldStart("divYieldFlag")
			s.DivYieldFlag.Encode(e)
		}
	}
	{
		if s.IssueKind.Set {
			e.FieldStart("issueKind")
			s.IssueKind.Encode(e)
		}
	}
	{
		if s.PlacementDate.Set {
			e.FieldStart("placementDate")
			s.PlacementDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RepresIsin.Set {
			e.FieldStart("represIsin")
			s.RepresIsin.Encode(e)
		}
	}
	{
		if s.IssueSizePlan.Set {
			e.FieldStart("issueSizePlan")
			s.IssueSizePlan.Encode(e)
		}
	}
	{
		if s.TotalFloat.Set {
			e.FieldStart("totalFloat")
			s.TotalFloat.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetShare = [15]string{
	0:  "type",
	1:  "issueSize",
	2:  "nominal",
	3:  "nominalCurrency",
	4:  "primaryIndex",
	5:  "dividendRate",
	6:  "preferredShareType",
	7:  "ipoDate",
	8:  "registryDate",
	9:  "divYieldFlag",
	10: "issueKind",
	11: "placementDate",
	12: "represIsin",
	13: "issueSizePlan",
	14: "totalFloat",
}

// Decode decodes V1AssetShare from json.
func (s *V1AssetShare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetShare to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "issueSize":
			if err := func() error {
				s.IssueSize.Reset()
				if err := s.IssueSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSize\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "nominalCurrency":
			if err := func() error {
				s.NominalCurrency.Reset()
				if err := s.NominalCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominalCurrency\"")
			}
		case "primaryIndex":
			if err := func() error {
				s.PrimaryIndex.Reset()
				if err := s.PrimaryIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primaryIndex\"")
			}
		case "dividendRate":
			if err := func() error {
				s.DividendRate.Reset()
				if err := s.DividendRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividendRate\"")
			}
		case "preferredShareType":
			if err := func() error {
				s.PreferredShareType.Reset()
				if err := s.PreferredShareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredShareType\"")
			}
		case "ipoDate":
			if err := func() error {
				s.IpoDate.Reset()
				if err := s.IpoDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipoDate\"")
			}
		case "registryDate":
			if err := func() error {
				s.RegistryDate.Reset()
				if err := s.RegistryDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registryDate\"")
			}
		case "divYieldFlag":
			if err := func() error {
				s.DivYieldFlag.Reset()
				if err := s.DivYieldFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"divYieldFlag\"")
			}
		case "issueKind":
			if err := func() error {
				s.IssueKind.Reset()
				if err := s.IssueKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueKind\"")
			}
		case "placementDate":
			if err := func() error {
				s.PlacementDate.Reset()
				if err := s.PlacementDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placementDate\"")
			}
		case "represIsin":
			if err := func() error {
				s.RepresIsin.Reset()
				if err := s.RepresIsin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"represIsin\"")
			}
		case "issueSizePlan":
			if err := func() error {
				s.IssueSizePlan.Reset()
				if err := s.IssueSizePlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSizePlan\"")
			}
		case "totalFloat":
			if err := func() error {
				s.TotalFloat.Reset()
				if err := s.TotalFloat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalFloat\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetShare")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetShare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetShare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetStructuredProduct) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetStructuredProduct) encodeFields(e *jx.Encoder) {
	{
		if s.BorrowName.Set {
			e.FieldStart("borrowName")
			s.BorrowName.Encode(e)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.NominalCurrency.Set {
			e.FieldStart("nominalCurrency")
			s.NominalCurrency.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.LogicPortfolio.Set {
			e.FieldStart("logicPortfolio")
			s.LogicPortfolio.Encode(e)
		}
	}
	{
		if s.AssetType.Set {
			e.FieldStart("assetType")
			s.AssetType.Encode(e)
		}
	}
	{
		if s.BasicAsset.Set {
			e.FieldStart("basicAsset")
			s.BasicAsset.Encode(e)
		}
	}
	{
		if s.SafetyBarrier.Set {
			e.FieldStart("safetyBarrier")
			s.SafetyBarrier.Encode(e)
		}
	}
	{
		if s.MaturityDate.Set {
			e.FieldStart("maturityDate")
			s.MaturityDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IssueSizePlan.Set {
			e.FieldStart("issueSizePlan")
			s.IssueSizePlan.Encode(e)
		}
	}
	{
		if s.IssueSize.Set {
			e.FieldStart("issueSize")
			s.IssueSize.Encode(e)
		}
	}
	{
		if s.PlacementDate.Set {
			e.FieldStart("placementDate")
			s.PlacementDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IssueKind.Set {
			e.FieldStart("issueKind")
			s.IssueKind.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1AssetStructuredProduct = [13]string{
	0:  "borrowName",
	1:  "nominal",
	2:  "nominalCurrency",
	3:  "type",
	4:  "logicPortfolio",
	5:  "assetType",
	6:  "basicAsset",
	7:  "safetyBarrier",
	8:  "maturityDate",
	9:  "issueSizePlan",
	10: "issueSize",
	11: "placementDate",
	12: "issueKind",
}

// Decode decodes V1AssetStructuredProduct from json.
func (s *V1AssetStructuredProduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetStructuredProduct to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "borrowName":
			if err := func() error {
				s.BorrowName.Reset()
				if err := s.BorrowName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"borrowName\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "nominalCurrency":
			if err := func() error {
				s.NominalCurrency.Reset()
				if err := s.NominalCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominalCurrency\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "logicPortfolio":
			if err := func() error {
				s.LogicPortfolio.Reset()
				if err := s.LogicPortfolio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logicPortfolio\"")
			}
		case "assetType":
			if err := func() error {
				s.AssetType.Reset()
				if err := s.AssetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetType\"")
			}
		case "basicAsset":
			if err := func() error {
				s.BasicAsset.Reset()
				if err := s.BasicAsset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAsset\"")
			}
		case "safetyBarrier":
			if err := func() error {
				s.SafetyBarrier.Reset()
				if err := s.SafetyBarrier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"safetyBarrier\"")
			}
		case "maturityDate":
			if err := func() error {
				s.MaturityDate.Reset()
				if err := s.MaturityDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maturityDate\"")
			}
		case "issueSizePlan":
			if err := func() error {
				s.IssueSizePlan.Reset()
				if err := s.IssueSizePlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSizePlan\"")
			}
		case "issueSize":
			if err := func() error {
				s.IssueSize.Reset()
				if err := s.IssueSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSize\"")
			}
		case "placementDate":
			if err := func() error {
				s.PlacementDate.Reset()
				if err := s.PlacementDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placementDate\"")
			}
		case "issueKind":
			if err := func() error {
				s.IssueKind.Reset()
				if err := s.IssueKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueKind\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetStructuredProduct")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetStructuredProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetStructuredProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1AssetType as json.
func (s V1AssetType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1AssetType from json.
func (s *V1AssetType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1AssetType(v) {
	case V1AssetTypeASSETTYPEUNSPECIFIED:
		*s = V1AssetTypeASSETTYPEUNSPECIFIED
	case V1AssetTypeASSETTYPECURRENCY:
		*s = V1AssetTypeASSETTYPECURRENCY
	case V1AssetTypeASSETTYPECOMMODITY:
		*s = V1AssetTypeASSETTYPECOMMODITY
	case V1AssetTypeASSETTYPEINDEX:
		*s = V1AssetTypeASSETTYPEINDEX
	case V1AssetTypeASSETTYPESECURITY:
		*s = V1AssetTypeASSETTYPESECURITY
	default:
		*s = V1AssetType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1AssetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetsRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1AssetsRequest = [0]string{}

// Decode decodes V1AssetsRequest from json.
func (s *V1AssetsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1AssetsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1AssetsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Assets != nil {
			e.FieldStart("assets")
			e.ArrStart()
			for _, elem := range s.Assets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1AssetsResponse = [1]string{
	0: "assets",
}

// Decode decodes V1AssetsResponse from json.
func (s *V1AssetsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1AssetsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assets":
			if err := func() error {
				s.Assets = make([]V1Asset, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Asset
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assets = append(s.Assets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1AssetsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1AssetsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1AssetsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Bond) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Bond) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.Lot.Set {
			e.FieldStart("lot")
			s.Lot.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Klong.Set {
			e.FieldStart("klong")
			s.Klong.Encode(e)
		}
	}
	{
		if s.Kshort.Set {
			e.FieldStart("kshort")
			s.Kshort.Encode(e)
		}
	}
	{
		if s.Dlong.Set {
			e.FieldStart("dlong")
			s.Dlong.Encode(e)
		}
	}
	{
		if s.Dshort.Set {
			e.FieldStart("dshort")
			s.Dshort.Encode(e)
		}
	}
	{
		if s.DlongMin.Set {
			e.FieldStart("dlongMin")
			s.DlongMin.Encode(e)
		}
	}
	{
		if s.DshortMin.Set {
			e.FieldStart("dshortMin")
			s.DshortMin.Encode(e)
		}
	}
	{
		if s.ShortEnabledFlag.Set {
			e.FieldStart("shortEnabledFlag")
			s.ShortEnabledFlag.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.CouponQuantityPerYear.Set {
			e.FieldStart("couponQuantityPerYear")
			s.CouponQuantityPerYear.Encode(e)
		}
	}
	{
		if s.MaturityDate.Set {
			e.FieldStart("maturityDate")
			s.MaturityDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.InitialNominal.Set {
			e.FieldStart("initialNominal")
			s.InitialNominal.Encode(e)
		}
	}
	{
		if s.StateRegDate.Set {
			e.FieldStart("stateRegDate")
			s.StateRegDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PlacementDate.Set {
			e.FieldStart("placementDate")
			s.PlacementDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PlacementPrice.Set {
			e.FieldStart("placementPrice")
			s.PlacementPrice.Encode(e)
		}
	}
	{
		if s.AciValue.Set {
			e.FieldStart("aciValue")
			s.AciValue.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
	{
		if s.Sector.Set {
			e.FieldStart("sector")
			s.Sector.Encode(e)
		}
	}
	{
		if s.IssueKind.Set {
			e.FieldStart("issueKind")
			s.IssueKind.Encode(e)
		}
	}
	{
		if s.IssueSize.Set {
			e.FieldStart("issueSize")
			s.IssueSize.Encode(e)
		}
	}
	{
		if s.IssueSizePlan.Set {
			e.FieldStart("issueSizePlan")
			s.IssueSizePlan.Encode(e)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.BuyAvailableFlag.Set {
			e.FieldStart("buyAvailableFlag")
			s.BuyAvailableFlag.Encode(e)
		}
	}
	{
		if s.SellAvailableFlag.Set {
			e.FieldStart("sellAvailableFlag")
			s.SellAvailableFlag.Encode(e)
		}
	}
	{
		if s.FloatingCouponFlag.Set {
			e.FieldStart("floatingCouponFlag")
			s.FloatingCouponFlag.Encode(e)
		}
	}
	{
		if s.PerpetualFlag.Set {
			e.FieldStart("perpetualFlag")
			s.PerpetualFlag.Encode(e)
		}
	}
	{
		if s.AmortizationFlag.Set {
			e.FieldStart("amortizationFlag")
			s.AmortizationFlag.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.RealExchange.Set {
			e.FieldStart("realExchange")
			s.RealExchange.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
	{
		if s.SubordinatedFlag.Set {
			e.FieldStart("subordinatedFlag")
			s.SubordinatedFlag.Encode(e)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RiskLevel.Set {
			e.FieldStart("riskLevel")
			s.RiskLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Bond = [49]string{
	0:  "figi",
	1:  "ticker",
	2:  "classCode",
	3:  "isin",
	4:  "lot",
	5:  "currency",
	6:  "klong",
	7:  "kshort",
	8:  "dlong",
	9:  "dshort",
	10: "dlongMin",
	11: "dshortMin",
	12: "shortEnabledFlag",
	13: "name",
	14: "exchange",
	15: "couponQuantityPerYear",
	16: "maturityDate",
	17: "nominal",
	18: "initialNominal",
	19: "stateRegDate",
	20: "placementDate",
	21: "placementPrice",
	22: "aciValue",
	23: "countryOfRisk",
	24: "countryOfRiskName",
	25: "sector",
	26: "issueKind",
	27: "issueSize",
	28: "issueSizePlan",
	29: "tradingStatus",
	30: "otcFlag",
	31: "buyAvailableFlag",
	32: "sellAvailableFlag",
	33: "floatingCouponFlag",
	34: "perpetualFlag",
	35: "amortizationFlag",
	36: "minPriceIncrement",
	37: "apiTradeAvailableFlag",
	38: "uid",
	39: "realExchange",
	40: "positionUid",
	41: "forIisFlag",
	42: "forQualInvestorFlag",
	43: "weekendFlag",
	44: "blockedTcaFlag",
	45: "subordinatedFlag",
	46: "first1minCandleDate",
	47: "first1dayCandleDate",
	48: "riskLevel",
}

// Decode decodes V1Bond from json.
func (s *V1Bond) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Bond to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "lot":
			if err := func() error {
				s.Lot.Reset()
				if err := s.Lot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "klong":
			if err := func() error {
				s.Klong.Reset()
				if err := s.Klong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"klong\"")
			}
		case "kshort":
			if err := func() error {
				s.Kshort.Reset()
				if err := s.Kshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kshort\"")
			}
		case "dlong":
			if err := func() error {
				s.Dlong.Reset()
				if err := s.Dlong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlong\"")
			}
		case "dshort":
			if err := func() error {
				s.Dshort.Reset()
				if err := s.Dshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshort\"")
			}
		case "dlongMin":
			if err := func() error {
				s.DlongMin.Reset()
				if err := s.DlongMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlongMin\"")
			}
		case "dshortMin":
			if err := func() error {
				s.DshortMin.Reset()
				if err := s.DshortMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshortMin\"")
			}
		case "shortEnabledFlag":
			if err := func() error {
				s.ShortEnabledFlag.Reset()
				if err := s.ShortEnabledFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortEnabledFlag\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "couponQuantityPerYear":
			if err := func() error {
				s.CouponQuantityPerYear.Reset()
				if err := s.CouponQuantityPerYear.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponQuantityPerYear\"")
			}
		case "maturityDate":
			if err := func() error {
				s.MaturityDate.Reset()
				if err := s.MaturityDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maturityDate\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "initialNominal":
			if err := func() error {
				s.InitialNominal.Reset()
				if err := s.InitialNominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialNominal\"")
			}
		case "stateRegDate":
			if err := func() error {
				s.StateRegDate.Reset()
				if err := s.StateRegDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stateRegDate\"")
			}
		case "placementDate":
			if err := func() error {
				s.PlacementDate.Reset()
				if err := s.PlacementDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placementDate\"")
			}
		case "placementPrice":
			if err := func() error {
				s.PlacementPrice.Reset()
				if err := s.PlacementPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placementPrice\"")
			}
		case "aciValue":
			if err := func() error {
				s.AciValue.Reset()
				if err := s.AciValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aciValue\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		case "sector":
			if err := func() error {
				s.Sector.Reset()
				if err := s.Sector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sector\"")
			}
		case "issueKind":
			if err := func() error {
				s.IssueKind.Reset()
				if err := s.IssueKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueKind\"")
			}
		case "issueSize":
			if err := func() error {
				s.IssueSize.Reset()
				if err := s.IssueSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSize\"")
			}
		case "issueSizePlan":
			if err := func() error {
				s.IssueSizePlan.Reset()
				if err := s.IssueSizePlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSizePlan\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "buyAvailableFlag":
			if err := func() error {
				s.BuyAvailableFlag.Reset()
				if err := s.BuyAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyAvailableFlag\"")
			}
		case "sellAvailableFlag":
			if err := func() error {
				s.SellAvailableFlag.Reset()
				if err := s.SellAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellAvailableFlag\"")
			}
		case "floatingCouponFlag":
			if err := func() error {
				s.FloatingCouponFlag.Reset()
				if err := s.FloatingCouponFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"floatingCouponFlag\"")
			}
		case "perpetualFlag":
			if err := func() error {
				s.PerpetualFlag.Reset()
				if err := s.PerpetualFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perpetualFlag\"")
			}
		case "amortizationFlag":
			if err := func() error {
				s.AmortizationFlag.Reset()
				if err := s.AmortizationFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amortizationFlag\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "realExchange":
			if err := func() error {
				s.RealExchange.Reset()
				if err := s.RealExchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realExchange\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		case "subordinatedFlag":
			if err := func() error {
				s.SubordinatedFlag.Reset()
				if err := s.SubordinatedFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subordinatedFlag\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		case "riskLevel":
			if err := func() error {
				s.RiskLevel.Reset()
				if err := s.RiskLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riskLevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Bond")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Bond) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Bond) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1BondResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1BondResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instrument.Set {
			e.FieldStart("instrument")
			s.Instrument.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1BondResponse = [1]string{
	0: "instrument",
}

// Decode decodes V1BondResponse from json.
func (s *V1BondResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1BondResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrument":
			if err := func() error {
				s.Instrument.Reset()
				if err := s.Instrument.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrument\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1BondResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1BondResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1BondResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1BondsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1BondsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1BondsResponse = [1]string{
	0: "instruments",
}

// Decode decodes V1BondsResponse from json.
func (s *V1BondsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1BondsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1Bond, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Bond
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1BondsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1BondsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1BondsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Brand) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Brand) encodeFields(e *jx.Encoder) {
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Info.Set {
			e.FieldStart("info")
			s.Info.Encode(e)
		}
	}
	{
		if s.Company.Set {
			e.FieldStart("company")
			s.Company.Encode(e)
		}
	}
	{
		if s.Sector.Set {
			e.FieldStart("sector")
			s.Sector.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Brand = [8]string{
	0: "uid",
	1: "name",
	2: "description",
	3: "info",
	4: "company",
	5: "sector",
	6: "countryOfRisk",
	7: "countryOfRiskName",
}

// Decode decodes V1Brand from json.
func (s *V1Brand) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Brand to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "info":
			if err := func() error {
				s.Info.Reset()
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "company":
			if err := func() error {
				s.Company.Reset()
				if err := s.Company.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"company\"")
			}
		case "sector":
			if err := func() error {
				s.Sector.Reset()
				if err := s.Sector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sector\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Brand")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Brand) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Brand) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1BrokerReport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1BrokerReport) encodeFields(e *jx.Encoder) {
	{
		if s.TradeId.Set {
			e.FieldStart("tradeId")
			s.TradeId.Encode(e)
		}
	}
	{
		if s.OrderId.Set {
			e.FieldStart("orderId")
			s.OrderId.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.ExecuteSign.Set {
			e.FieldStart("executeSign")
			s.ExecuteSign.Encode(e)
		}
	}
	{
		if s.TradeDatetime.Set {
			e.FieldStart("tradeDatetime")
			s.TradeDatetime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.OrderAmount.Set {
			e.FieldStart("orderAmount")
			s.OrderAmount.Encode(e)
		}
	}
	{
		if s.AciValue.Set {
			e.FieldStart("aciValue")
			s.AciValue.Encode(e)
		}
	}
	{
		if s.TotalOrderAmount.Set {
			e.FieldStart("totalOrderAmount")
			s.TotalOrderAmount.Encode(e)
		}
	}
	{
		if s.BrokerCommission.Set {
			e.FieldStart("brokerCommission")
			s.BrokerCommission.Encode(e)
		}
	}
	{
		if s.ExchangeCommission.Set {
			e.FieldStart("exchangeCommission")
			s.ExchangeCommission.Encode(e)
		}
	}
	{
		if s.ExchangeClearingCommission.Set {
			e.FieldStart("exchangeClearingCommission")
			s.ExchangeClearingCommission.Encode(e)
		}
	}
	{
		if s.RepoRate.Set {
			e.FieldStart("repoRate")
			s.RepoRate.Encode(e)
		}
	}
	{
		if s.Party.Set {
			e.FieldStart("party")
			s.Party.Encode(e)
		}
	}
	{
		if s.ClearValueDate.Set {
			e.FieldStart("clearValueDate")
			s.ClearValueDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SecValueDate.Set {
			e.FieldStart("secValueDate")
			s.SecValueDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BrokerStatus.Set {
			e.FieldStart("brokerStatus")
			s.BrokerStatus.Encode(e)
		}
	}
	{
		if s.SeparateAgreementType.Set {
			e.FieldStart("separateAgreementType")
			s.SeparateAgreementType.Encode(e)
		}
	}
	{
		if s.SeparateAgreementNumber.Set {
			e.FieldStart("separateAgreementNumber")
			s.SeparateAgreementNumber.Encode(e)
		}
	}
	{
		if s.SeparateAgreementDate.Set {
			e.FieldStart("separateAgreementDate")
			s.SeparateAgreementDate.Encode(e)
		}
	}
	{
		if s.DeliveryType.Set {
			e.FieldStart("deliveryType")
			s.DeliveryType.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1BrokerReport = [27]string{
	0:  "tradeId",
	1:  "orderId",
	2:  "figi",
	3:  "executeSign",
	4:  "tradeDatetime",
	5:  "exchange",
	6:  "classCode",
	7:  "direction",
	8:  "name",
	9:  "ticker",
	10: "price",
	11: "quantity",
	12: "orderAmount",
	13: "aciValue",
	14: "totalOrderAmount",
	15: "brokerCommission",
	16: "exchangeCommission",
	17: "exchangeClearingCommission",
	18: "repoRate",
	19: "party",
	20: "clearValueDate",
	21: "secValueDate",
	22: "brokerStatus",
	23: "separateAgreementType",
	24: "separateAgreementNumber",
	25: "separateAgreementDate",
	26: "deliveryType",
}

// Decode decodes V1BrokerReport from json.
func (s *V1BrokerReport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1BrokerReport to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tradeId":
			if err := func() error {
				s.TradeId.Reset()
				if err := s.TradeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeId\"")
			}
		case "orderId":
			if err := func() error {
				s.OrderId.Reset()
				if err := s.OrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "executeSign":
			if err := func() error {
				s.ExecuteSign.Reset()
				if err := s.ExecuteSign.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executeSign\"")
			}
		case "tradeDatetime":
			if err := func() error {
				s.TradeDatetime.Reset()
				if err := s.TradeDatetime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeDatetime\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "orderAmount":
			if err := func() error {
				s.OrderAmount.Reset()
				if err := s.OrderAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderAmount\"")
			}
		case "aciValue":
			if err := func() error {
				s.AciValue.Reset()
				if err := s.AciValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aciValue\"")
			}
		case "totalOrderAmount":
			if err := func() error {
				s.TotalOrderAmount.Reset()
				if err := s.TotalOrderAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalOrderAmount\"")
			}
		case "brokerCommission":
			if err := func() error {
				s.BrokerCommission.Reset()
				if err := s.BrokerCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerCommission\"")
			}
		case "exchangeCommission":
			if err := func() error {
				s.ExchangeCommission.Reset()
				if err := s.ExchangeCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchangeCommission\"")
			}
		case "exchangeClearingCommission":
			if err := func() error {
				s.ExchangeClearingCommission.Reset()
				if err := s.ExchangeClearingCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchangeClearingCommission\"")
			}
		case "repoRate":
			if err := func() error {
				s.RepoRate.Reset()
				if err := s.RepoRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repoRate\"")
			}
		case "party":
			if err := func() error {
				s.Party.Reset()
				if err := s.Party.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"party\"")
			}
		case "clearValueDate":
			if err := func() error {
				s.ClearValueDate.Reset()
				if err := s.ClearValueDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clearValueDate\"")
			}
		case "secValueDate":
			if err := func() error {
				s.SecValueDate.Reset()
				if err := s.SecValueDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secValueDate\"")
			}
		case "brokerStatus":
			if err := func() error {
				s.BrokerStatus.Reset()
				if err := s.BrokerStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerStatus\"")
			}
		case "separateAgreementType":
			if err := func() error {
				s.SeparateAgreementType.Reset()
				if err := s.SeparateAgreementType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"separateAgreementType\"")
			}
		case "separateAgreementNumber":
			if err := func() error {
				s.SeparateAgreementNumber.Reset()
				if err := s.SeparateAgreementNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"separateAgreementNumber\"")
			}
		case "separateAgreementDate":
			if err := func() error {
				s.SeparateAgreementDate.Reset()
				if err := s.SeparateAgreementDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"separateAgreementDate\"")
			}
		case "deliveryType":
			if err := func() error {
				s.DeliveryType.Reset()
				if err := s.DeliveryType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deliveryType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1BrokerReport")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1BrokerReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1BrokerReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1BrokerReportRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1BrokerReportRequest) encodeFields(e *jx.Encoder) {
	{
		if s.GenerateBrokerReportRequest.Set {
			e.FieldStart("generateBrokerReportRequest")
			s.GenerateBrokerReportRequest.Encode(e)
		}
	}
	{
		if s.GetBrokerReportRequest.Set {
			e.FieldStart("getBrokerReportRequest")
			s.GetBrokerReportRequest.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1BrokerReportRequest = [2]string{
	0: "generateBrokerReportRequest",
	1: "getBrokerReportRequest",
}

// Decode decodes V1BrokerReportRequest from json.
func (s *V1BrokerReportRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1BrokerReportRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "generateBrokerReportRequest":
			if err := func() error {
				s.GenerateBrokerReportRequest.Reset()
				if err := s.GenerateBrokerReportRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generateBrokerReportRequest\"")
			}
		case "getBrokerReportRequest":
			if err := func() error {
				s.GetBrokerReportRequest.Reset()
				if err := s.GetBrokerReportRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getBrokerReportRequest\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1BrokerReportRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1BrokerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1BrokerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1BrokerReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1BrokerReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.GenerateBrokerReportResponse.Set {
			e.FieldStart("generateBrokerReportResponse")
			s.GenerateBrokerReportResponse.Encode(e)
		}
	}
	{
		if s.GetBrokerReportResponse.Set {
			e.FieldStart("getBrokerReportResponse")
			s.GetBrokerReportResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1BrokerReportResponse = [2]string{
	0: "generateBrokerReportResponse",
	1: "getBrokerReportResponse",
}

// Decode decodes V1BrokerReportResponse from json.
func (s *V1BrokerReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1BrokerReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "generateBrokerReportResponse":
			if err := func() error {
				s.GenerateBrokerReportResponse.Reset()
				if err := s.GenerateBrokerReportResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generateBrokerReportResponse\"")
			}
		case "getBrokerReportResponse":
			if err := func() error {
				s.GetBrokerReportResponse.Reset()
				if err := s.GetBrokerReportResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getBrokerReportResponse\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1BrokerReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1BrokerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1BrokerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CancelOrderRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CancelOrderRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.OrderId.Set {
			e.FieldStart("orderId")
			s.OrderId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1CancelOrderRequest = [2]string{
	0: "accountId",
	1: "orderId",
}

// Decode decodes V1CancelOrderRequest from json.
func (s *V1CancelOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CancelOrderRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "orderId":
			if err := func() error {
				s.OrderId.Reset()
				if err := s.OrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CancelOrderRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CancelOrderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CancelOrderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CancelOrderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CancelOrderResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1CancelOrderResponse = [1]string{
	0: "time",
}

// Decode decodes V1CancelOrderResponse from json.
func (s *V1CancelOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CancelOrderResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CancelOrderResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CancelOrderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CancelOrderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CancelStopOrderRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CancelStopOrderRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.StopOrderId.Set {
			e.FieldStart("stopOrderId")
			s.StopOrderId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1CancelStopOrderRequest = [2]string{
	0: "accountId",
	1: "stopOrderId",
}

// Decode decodes V1CancelStopOrderRequest from json.
func (s *V1CancelStopOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CancelStopOrderRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "stopOrderId":
			if err := func() error {
				s.StopOrderId.Reset()
				if err := s.StopOrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopOrderId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CancelStopOrderRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CancelStopOrderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CancelStopOrderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CancelStopOrderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CancelStopOrderResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1CancelStopOrderResponse = [1]string{
	0: "time",
}

// Decode decodes V1CancelStopOrderResponse from json.
func (s *V1CancelStopOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CancelStopOrderResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CancelStopOrderResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CancelStopOrderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CancelStopOrderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1CandleInterval as json.
func (s V1CandleInterval) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1CandleInterval from json.
func (s *V1CandleInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CandleInterval to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1CandleInterval(v) {
	case V1CandleIntervalCANDLEINTERVALUNSPECIFIED:
		*s = V1CandleIntervalCANDLEINTERVALUNSPECIFIED
	case V1CandleIntervalCANDLEINTERVAL1MIN:
		*s = V1CandleIntervalCANDLEINTERVAL1MIN
	case V1CandleIntervalCANDLEINTERVAL5MIN:
		*s = V1CandleIntervalCANDLEINTERVAL5MIN
	case V1CandleIntervalCANDLEINTERVAL15MIN:
		*s = V1CandleIntervalCANDLEINTERVAL15MIN
	case V1CandleIntervalCANDLEINTERVALHOUR:
		*s = V1CandleIntervalCANDLEINTERVALHOUR
	case V1CandleIntervalCANDLEINTERVALDAY:
		*s = V1CandleIntervalCANDLEINTERVALDAY
	case V1CandleIntervalCANDLEINTERVAL2MIN:
		*s = V1CandleIntervalCANDLEINTERVAL2MIN
	case V1CandleIntervalCANDLEINTERVAL3MIN:
		*s = V1CandleIntervalCANDLEINTERVAL3MIN
	case V1CandleIntervalCANDLEINTERVAL10MIN:
		*s = V1CandleIntervalCANDLEINTERVAL10MIN
	case V1CandleIntervalCANDLEINTERVAL30MIN:
		*s = V1CandleIntervalCANDLEINTERVAL30MIN
	case V1CandleIntervalCANDLEINTERVAL2HOUR:
		*s = V1CandleIntervalCANDLEINTERVAL2HOUR
	case V1CandleIntervalCANDLEINTERVAL4HOUR:
		*s = V1CandleIntervalCANDLEINTERVAL4HOUR
	case V1CandleIntervalCANDLEINTERVALWEEK:
		*s = V1CandleIntervalCANDLEINTERVALWEEK
	case V1CandleIntervalCANDLEINTERVALMONTH:
		*s = V1CandleIntervalCANDLEINTERVALMONTH
	default:
		*s = V1CandleInterval(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1CandleInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CandleInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CloseSandboxAccountRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CloseSandboxAccountRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1CloseSandboxAccountRequest = [1]string{
	0: "accountId",
}

// Decode decodes V1CloseSandboxAccountRequest from json.
func (s *V1CloseSandboxAccountRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CloseSandboxAccountRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CloseSandboxAccountRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CloseSandboxAccountRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CloseSandboxAccountRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CloseSandboxAccountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CloseSandboxAccountResponse) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1CloseSandboxAccountResponse = [0]string{}

// Decode decodes V1CloseSandboxAccountResponse from json.
func (s *V1CloseSandboxAccountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CloseSandboxAccountResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CloseSandboxAccountResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CloseSandboxAccountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CloseSandboxAccountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CountryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CountryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.AlfaTwo.Set {
			e.FieldStart("alfaTwo")
			s.AlfaTwo.Encode(e)
		}
	}
	{
		if s.AlfaThree.Set {
			e.FieldStart("alfaThree")
			s.AlfaThree.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NameBrief.Set {
			e.FieldStart("nameBrief")
			s.NameBrief.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1CountryResponse = [4]string{
	0: "alfaTwo",
	1: "alfaThree",
	2: "name",
	3: "nameBrief",
}

// Decode decodes V1CountryResponse from json.
func (s *V1CountryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CountryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alfaTwo":
			if err := func() error {
				s.AlfaTwo.Reset()
				if err := s.AlfaTwo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alfaTwo\"")
			}
		case "alfaThree":
			if err := func() error {
				s.AlfaThree.Reset()
				if err := s.AlfaThree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alfaThree\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nameBrief":
			if err := func() error {
				s.NameBrief.Reset()
				if err := s.NameBrief.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameBrief\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CountryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CountryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CountryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Coupon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Coupon) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.CouponDate.Set {
			e.FieldStart("couponDate")
			s.CouponDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CouponNumber.Set {
			e.FieldStart("couponNumber")
			s.CouponNumber.Encode(e)
		}
	}
	{
		if s.FixDate.Set {
			e.FieldStart("fixDate")
			s.FixDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PayOneBond.Set {
			e.FieldStart("payOneBond")
			s.PayOneBond.Encode(e)
		}
	}
	{
		if s.CouponType.Set {
			e.FieldStart("couponType")
			s.CouponType.Encode(e)
		}
	}
	{
		if s.CouponStartDate.Set {
			e.FieldStart("couponStartDate")
			s.CouponStartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CouponEndDate.Set {
			e.FieldStart("couponEndDate")
			s.CouponEndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CouponPeriod.Set {
			e.FieldStart("couponPeriod")
			s.CouponPeriod.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Coupon = [9]string{
	0: "figi",
	1: "couponDate",
	2: "couponNumber",
	3: "fixDate",
	4: "payOneBond",
	5: "couponType",
	6: "couponStartDate",
	7: "couponEndDate",
	8: "couponPeriod",
}

// Decode decodes V1Coupon from json.
func (s *V1Coupon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Coupon to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "couponDate":
			if err := func() error {
				s.CouponDate.Reset()
				if err := s.CouponDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponDate\"")
			}
		case "couponNumber":
			if err := func() error {
				s.CouponNumber.Reset()
				if err := s.CouponNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponNumber\"")
			}
		case "fixDate":
			if err := func() error {
				s.FixDate.Reset()
				if err := s.FixDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fixDate\"")
			}
		case "payOneBond":
			if err := func() error {
				s.PayOneBond.Reset()
				if err := s.PayOneBond.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payOneBond\"")
			}
		case "couponType":
			if err := func() error {
				s.CouponType.Reset()
				if err := s.CouponType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponType\"")
			}
		case "couponStartDate":
			if err := func() error {
				s.CouponStartDate.Reset()
				if err := s.CouponStartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponStartDate\"")
			}
		case "couponEndDate":
			if err := func() error {
				s.CouponEndDate.Reset()
				if err := s.CouponEndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponEndDate\"")
			}
		case "couponPeriod":
			if err := func() error {
				s.CouponPeriod.Reset()
				if err := s.CouponPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couponPeriod\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Coupon")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Coupon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Coupon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1CouponType as json.
func (s V1CouponType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1CouponType from json.
func (s *V1CouponType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CouponType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1CouponType(v) {
	case V1CouponTypeCOUPONTYPEUNSPECIFIED:
		*s = V1CouponTypeCOUPONTYPEUNSPECIFIED
	case V1CouponTypeCOUPONTYPECONSTANT:
		*s = V1CouponTypeCOUPONTYPECONSTANT
	case V1CouponTypeCOUPONTYPEFLOATING:
		*s = V1CouponTypeCOUPONTYPEFLOATING
	case V1CouponTypeCOUPONTYPEDISCOUNT:
		*s = V1CouponTypeCOUPONTYPEDISCOUNT
	case V1CouponTypeCOUPONTYPEMORTGAGE:
		*s = V1CouponTypeCOUPONTYPEMORTGAGE
	case V1CouponTypeCOUPONTYPEFIX:
		*s = V1CouponTypeCOUPONTYPEFIX
	case V1CouponTypeCOUPONTYPEVARIABLE:
		*s = V1CouponTypeCOUPONTYPEVARIABLE
	case V1CouponTypeCOUPONTYPEOTHER:
		*s = V1CouponTypeCOUPONTYPEOTHER
	default:
		*s = V1CouponType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1CouponType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CouponType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CurrenciesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CurrenciesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1CurrenciesResponse = [1]string{
	0: "instruments",
}

// Decode decodes V1CurrenciesResponse from json.
func (s *V1CurrenciesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CurrenciesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1Currency, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Currency
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CurrenciesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CurrenciesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CurrenciesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Currency) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Currency) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.Lot.Set {
			e.FieldStart("lot")
			s.Lot.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Klong.Set {
			e.FieldStart("klong")
			s.Klong.Encode(e)
		}
	}
	{
		if s.Kshort.Set {
			e.FieldStart("kshort")
			s.Kshort.Encode(e)
		}
	}
	{
		if s.Dlong.Set {
			e.FieldStart("dlong")
			s.Dlong.Encode(e)
		}
	}
	{
		if s.Dshort.Set {
			e.FieldStart("dshort")
			s.Dshort.Encode(e)
		}
	}
	{
		if s.DlongMin.Set {
			e.FieldStart("dlongMin")
			s.DlongMin.Encode(e)
		}
	}
	{
		if s.DshortMin.Set {
			e.FieldStart("dshortMin")
			s.DshortMin.Encode(e)
		}
	}
	{
		if s.ShortEnabledFlag.Set {
			e.FieldStart("shortEnabledFlag")
			s.ShortEnabledFlag.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.BuyAvailableFlag.Set {
			e.FieldStart("buyAvailableFlag")
			s.BuyAvailableFlag.Encode(e)
		}
	}
	{
		if s.SellAvailableFlag.Set {
			e.FieldStart("sellAvailableFlag")
			s.SellAvailableFlag.Encode(e)
		}
	}
	{
		if s.IsoCurrencyName.Set {
			e.FieldStart("isoCurrencyName")
			s.IsoCurrencyName.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.RealExchange.Set {
			e.FieldStart("realExchange")
			s.RealExchange.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1Currency = [34]string{
	0:  "figi",
	1:  "ticker",
	2:  "classCode",
	3:  "isin",
	4:  "lot",
	5:  "currency",
	6:  "klong",
	7:  "kshort",
	8:  "dlong",
	9:  "dshort",
	10: "dlongMin",
	11: "dshortMin",
	12: "shortEnabledFlag",
	13: "name",
	14: "exchange",
	15: "nominal",
	16: "countryOfRisk",
	17: "countryOfRiskName",
	18: "tradingStatus",
	19: "otcFlag",
	20: "buyAvailableFlag",
	21: "sellAvailableFlag",
	22: "isoCurrencyName",
	23: "minPriceIncrement",
	24: "apiTradeAvailableFlag",
	25: "uid",
	26: "realExchange",
	27: "positionUid",
	28: "forIisFlag",
	29: "forQualInvestorFlag",
	30: "weekendFlag",
	31: "blockedTcaFlag",
	32: "first1minCandleDate",
	33: "first1dayCandleDate",
}

// Decode decodes V1Currency from json.
func (s *V1Currency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Currency to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "lot":
			if err := func() error {
				s.Lot.Reset()
				if err := s.Lot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "klong":
			if err := func() error {
				s.Klong.Reset()
				if err := s.Klong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"klong\"")
			}
		case "kshort":
			if err := func() error {
				s.Kshort.Reset()
				if err := s.Kshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kshort\"")
			}
		case "dlong":
			if err := func() error {
				s.Dlong.Reset()
				if err := s.Dlong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlong\"")
			}
		case "dshort":
			if err := func() error {
				s.Dshort.Reset()
				if err := s.Dshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshort\"")
			}
		case "dlongMin":
			if err := func() error {
				s.DlongMin.Reset()
				if err := s.DlongMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlongMin\"")
			}
		case "dshortMin":
			if err := func() error {
				s.DshortMin.Reset()
				if err := s.DshortMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshortMin\"")
			}
		case "shortEnabledFlag":
			if err := func() error {
				s.ShortEnabledFlag.Reset()
				if err := s.ShortEnabledFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortEnabledFlag\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "buyAvailableFlag":
			if err := func() error {
				s.BuyAvailableFlag.Reset()
				if err := s.BuyAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyAvailableFlag\"")
			}
		case "sellAvailableFlag":
			if err := func() error {
				s.SellAvailableFlag.Reset()
				if err := s.SellAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellAvailableFlag\"")
			}
		case "isoCurrencyName":
			if err := func() error {
				s.IsoCurrencyName.Reset()
				if err := s.IsoCurrencyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isoCurrencyName\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "realExchange":
			if err := func() error {
				s.RealExchange.Reset()
				if err := s.RealExchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realExchange\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Currency")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Currency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Currency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1CurrencyResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1CurrencyResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instrument.Set {
			e.FieldStart("instrument")
			s.Instrument.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1CurrencyResponse = [1]string{
	0: "instrument",
}

// Decode decodes V1CurrencyResponse from json.
func (s *V1CurrencyResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1CurrencyResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrument":
			if err := func() error {
				s.Instrument.Reset()
				if err := s.Instrument.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrument\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1CurrencyResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1CurrencyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1CurrencyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Dividend) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Dividend) encodeFields(e *jx.Encoder) {
	{
		if s.DividendNet.Set {
			e.FieldStart("dividendNet")
			s.DividendNet.Encode(e)
		}
	}
	{
		if s.PaymentDate.Set {
			e.FieldStart("paymentDate")
			s.PaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DeclaredDate.Set {
			e.FieldStart("declaredDate")
			s.DeclaredDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastBuyDate.Set {
			e.FieldStart("lastBuyDate")
			s.LastBuyDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DividendType.Set {
			e.FieldStart("dividendType")
			s.DividendType.Encode(e)
		}
	}
	{
		if s.RecordDate.Set {
			e.FieldStart("recordDate")
			s.RecordDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Regularity.Set {
			e.FieldStart("regularity")
			s.Regularity.Encode(e)
		}
	}
	{
		if s.ClosePrice.Set {
			e.FieldStart("closePrice")
			s.ClosePrice.Encode(e)
		}
	}
	{
		if s.YieldValue.Set {
			e.FieldStart("yieldValue")
			s.YieldValue.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1Dividend = [10]string{
	0: "dividendNet",
	1: "paymentDate",
	2: "declaredDate",
	3: "lastBuyDate",
	4: "dividendType",
	5: "recordDate",
	6: "regularity",
	7: "closePrice",
	8: "yieldValue",
	9: "createdAt",
}

// Decode decodes V1Dividend from json.
func (s *V1Dividend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Dividend to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dividendNet":
			if err := func() error {
				s.DividendNet.Reset()
				if err := s.DividendNet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividendNet\"")
			}
		case "paymentDate":
			if err := func() error {
				s.PaymentDate.Reset()
				if err := s.PaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paymentDate\"")
			}
		case "declaredDate":
			if err := func() error {
				s.DeclaredDate.Reset()
				if err := s.DeclaredDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"declaredDate\"")
			}
		case "lastBuyDate":
			if err := func() error {
				s.LastBuyDate.Reset()
				if err := s.LastBuyDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastBuyDate\"")
			}
		case "dividendType":
			if err := func() error {
				s.DividendType.Reset()
				if err := s.DividendType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividendType\"")
			}
		case "recordDate":
			if err := func() error {
				s.RecordDate.Reset()
				if err := s.RecordDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordDate\"")
			}
		case "regularity":
			if err := func() error {
				s.Regularity.Reset()
				if err := s.Regularity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regularity\"")
			}
		case "closePrice":
			if err := func() error {
				s.ClosePrice.Reset()
				if err := s.ClosePrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closePrice\"")
			}
		case "yieldValue":
			if err := func() error {
				s.YieldValue.Reset()
				if err := s.YieldValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yieldValue\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Dividend")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Dividend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Dividend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1DividendsForeignIssuerReport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1DividendsForeignIssuerReport) encodeFields(e *jx.Encoder) {
	{
		if s.RecordDate.Set {
			e.FieldStart("recordDate")
			s.RecordDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PaymentDate.Set {
			e.FieldStart("paymentDate")
			s.PaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SecurityName.Set {
			e.FieldStart("securityName")
			s.SecurityName.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.IssuerCountry.Set {
			e.FieldStart("issuerCountry")
			s.IssuerCountry.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Dividend.Set {
			e.FieldStart("dividend")
			s.Dividend.Encode(e)
		}
	}
	{
		if s.ExternalCommission.Set {
			e.FieldStart("externalCommission")
			s.ExternalCommission.Encode(e)
		}
	}
	{
		if s.DividendGross.Set {
			e.FieldStart("dividendGross")
			s.DividendGross.Encode(e)
		}
	}
	{
		if s.Tax.Set {
			e.FieldStart("tax")
			s.Tax.Encode(e)
		}
	}
	{
		if s.DividendAmount.Set {
			e.FieldStart("dividendAmount")
			s.DividendAmount.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1DividendsForeignIssuerReport = [12]string{
	0:  "recordDate",
	1:  "paymentDate",
	2:  "securityName",
	3:  "isin",
	4:  "issuerCountry",
	5:  "quantity",
	6:  "dividend",
	7:  "externalCommission",
	8:  "dividendGross",
	9:  "tax",
	10: "dividendAmount",
	11: "currency",
}

// Decode decodes V1DividendsForeignIssuerReport from json.
func (s *V1DividendsForeignIssuerReport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1DividendsForeignIssuerReport to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recordDate":
			if err := func() error {
				s.RecordDate.Reset()
				if err := s.RecordDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordDate\"")
			}
		case "paymentDate":
			if err := func() error {
				s.PaymentDate.Reset()
				if err := s.PaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paymentDate\"")
			}
		case "securityName":
			if err := func() error {
				s.SecurityName.Reset()
				if err := s.SecurityName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityName\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "issuerCountry":
			if err := func() error {
				s.IssuerCountry.Reset()
				if err := s.IssuerCountry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuerCountry\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "dividend":
			if err := func() error {
				s.Dividend.Reset()
				if err := s.Dividend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividend\"")
			}
		case "externalCommission":
			if err := func() error {
				s.ExternalCommission.Reset()
				if err := s.ExternalCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalCommission\"")
			}
		case "dividendGross":
			if err := func() error {
				s.DividendGross.Reset()
				if err := s.DividendGross.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividendGross\"")
			}
		case "tax":
			if err := func() error {
				s.Tax.Reset()
				if err := s.Tax.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tax\"")
			}
		case "dividendAmount":
			if err := func() error {
				s.DividendAmount.Reset()
				if err := s.DividendAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividendAmount\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1DividendsForeignIssuerReport")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1DividendsForeignIssuerReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1DividendsForeignIssuerReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1EditFavoritesActionType as json.
func (s V1EditFavoritesActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1EditFavoritesActionType from json.
func (s *V1EditFavoritesActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1EditFavoritesActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1EditFavoritesActionType(v) {
	case V1EditFavoritesActionTypeEDITFAVORITESACTIONTYPEUNSPECIFIED:
		*s = V1EditFavoritesActionTypeEDITFAVORITESACTIONTYPEUNSPECIFIED
	case V1EditFavoritesActionTypeEDITFAVORITESACTIONTYPEADD:
		*s = V1EditFavoritesActionTypeEDITFAVORITESACTIONTYPEADD
	case V1EditFavoritesActionTypeEDITFAVORITESACTIONTYPEDEL:
		*s = V1EditFavoritesActionTypeEDITFAVORITESACTIONTYPEDEL
	default:
		*s = V1EditFavoritesActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1EditFavoritesActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1EditFavoritesActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1EditFavoritesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1EditFavoritesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ActionType.Set {
			e.FieldStart("actionType")
			s.ActionType.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1EditFavoritesRequest = [2]string{
	0: "instruments",
	1: "actionType",
}

// Decode decodes V1EditFavoritesRequest from json.
func (s *V1EditFavoritesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1EditFavoritesRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1EditFavoritesRequestInstrument, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1EditFavoritesRequestInstrument
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		case "actionType":
			if err := func() error {
				s.ActionType.Reset()
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1EditFavoritesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1EditFavoritesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1EditFavoritesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1EditFavoritesRequestInstrument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1EditFavoritesRequestInstrument) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1EditFavoritesRequestInstrument = [1]string{
	0: "figi",
}

// Decode decodes V1EditFavoritesRequestInstrument from json.
func (s *V1EditFavoritesRequestInstrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1EditFavoritesRequestInstrument to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1EditFavoritesRequestInstrument")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1EditFavoritesRequestInstrument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1EditFavoritesRequestInstrument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1EditFavoritesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1EditFavoritesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.FavoriteInstruments != nil {
			e.FieldStart("favoriteInstruments")
			e.ArrStart()
			for _, elem := range s.FavoriteInstruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1EditFavoritesResponse = [1]string{
	0: "favoriteInstruments",
}

// Decode decodes V1EditFavoritesResponse from json.
func (s *V1EditFavoritesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1EditFavoritesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "favoriteInstruments":
			if err := func() error {
				s.FavoriteInstruments = make([]V1FavoriteInstrument, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1FavoriteInstrument
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FavoriteInstruments = append(s.FavoriteInstruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favoriteInstruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1EditFavoritesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1EditFavoritesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1EditFavoritesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Etf) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Etf) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.Lot.Set {
			e.FieldStart("lot")
			s.Lot.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Klong.Set {
			e.FieldStart("klong")
			s.Klong.Encode(e)
		}
	}
	{
		if s.Kshort.Set {
			e.FieldStart("kshort")
			s.Kshort.Encode(e)
		}
	}
	{
		if s.Dlong.Set {
			e.FieldStart("dlong")
			s.Dlong.Encode(e)
		}
	}
	{
		if s.Dshort.Set {
			e.FieldStart("dshort")
			s.Dshort.Encode(e)
		}
	}
	{
		if s.DlongMin.Set {
			e.FieldStart("dlongMin")
			s.DlongMin.Encode(e)
		}
	}
	{
		if s.DshortMin.Set {
			e.FieldStart("dshortMin")
			s.DshortMin.Encode(e)
		}
	}
	{
		if s.ShortEnabledFlag.Set {
			e.FieldStart("shortEnabledFlag")
			s.ShortEnabledFlag.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.FixedCommission.Set {
			e.FieldStart("fixedCommission")
			s.FixedCommission.Encode(e)
		}
	}
	{
		if s.FocusType.Set {
			e.FieldStart("focusType")
			s.FocusType.Encode(e)
		}
	}
	{
		if s.ReleasedDate.Set {
			e.FieldStart("releasedDate")
			s.ReleasedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NumShares.Set {
			e.FieldStart("numShares")
			s.NumShares.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
	{
		if s.Sector.Set {
			e.FieldStart("sector")
			s.Sector.Encode(e)
		}
	}
	{
		if s.RebalancingFreq.Set {
			e.FieldStart("rebalancingFreq")
			s.RebalancingFreq.Encode(e)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.BuyAvailableFlag.Set {
			e.FieldStart("buyAvailableFlag")
			s.BuyAvailableFlag.Encode(e)
		}
	}
	{
		if s.SellAvailableFlag.Set {
			e.FieldStart("sellAvailableFlag")
			s.SellAvailableFlag.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.RealExchange.Set {
			e.FieldStart("realExchange")
			s.RealExchange.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1Etf = [38]string{
	0:  "figi",
	1:  "ticker",
	2:  "classCode",
	3:  "isin",
	4:  "lot",
	5:  "currency",
	6:  "klong",
	7:  "kshort",
	8:  "dlong",
	9:  "dshort",
	10: "dlongMin",
	11: "dshortMin",
	12: "shortEnabledFlag",
	13: "name",
	14: "exchange",
	15: "fixedCommission",
	16: "focusType",
	17: "releasedDate",
	18: "numShares",
	19: "countryOfRisk",
	20: "countryOfRiskName",
	21: "sector",
	22: "rebalancingFreq",
	23: "tradingStatus",
	24: "otcFlag",
	25: "buyAvailableFlag",
	26: "sellAvailableFlag",
	27: "minPriceIncrement",
	28: "apiTradeAvailableFlag",
	29: "uid",
	30: "realExchange",
	31: "positionUid",
	32: "forIisFlag",
	33: "forQualInvestorFlag",
	34: "weekendFlag",
	35: "blockedTcaFlag",
	36: "first1minCandleDate",
	37: "first1dayCandleDate",
}

// Decode decodes V1Etf from json.
func (s *V1Etf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Etf to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "lot":
			if err := func() error {
				s.Lot.Reset()
				if err := s.Lot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "klong":
			if err := func() error {
				s.Klong.Reset()
				if err := s.Klong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"klong\"")
			}
		case "kshort":
			if err := func() error {
				s.Kshort.Reset()
				if err := s.Kshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kshort\"")
			}
		case "dlong":
			if err := func() error {
				s.Dlong.Reset()
				if err := s.Dlong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlong\"")
			}
		case "dshort":
			if err := func() error {
				s.Dshort.Reset()
				if err := s.Dshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshort\"")
			}
		case "dlongMin":
			if err := func() error {
				s.DlongMin.Reset()
				if err := s.DlongMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlongMin\"")
			}
		case "dshortMin":
			if err := func() error {
				s.DshortMin.Reset()
				if err := s.DshortMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshortMin\"")
			}
		case "shortEnabledFlag":
			if err := func() error {
				s.ShortEnabledFlag.Reset()
				if err := s.ShortEnabledFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortEnabledFlag\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "fixedCommission":
			if err := func() error {
				s.FixedCommission.Reset()
				if err := s.FixedCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fixedCommission\"")
			}
		case "focusType":
			if err := func() error {
				s.FocusType.Reset()
				if err := s.FocusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"focusType\"")
			}
		case "releasedDate":
			if err := func() error {
				s.ReleasedDate.Reset()
				if err := s.ReleasedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"releasedDate\"")
			}
		case "numShares":
			if err := func() error {
				s.NumShares.Reset()
				if err := s.NumShares.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numShares\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		case "sector":
			if err := func() error {
				s.Sector.Reset()
				if err := s.Sector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sector\"")
			}
		case "rebalancingFreq":
			if err := func() error {
				s.RebalancingFreq.Reset()
				if err := s.RebalancingFreq.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalancingFreq\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "buyAvailableFlag":
			if err := func() error {
				s.BuyAvailableFlag.Reset()
				if err := s.BuyAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyAvailableFlag\"")
			}
		case "sellAvailableFlag":
			if err := func() error {
				s.SellAvailableFlag.Reset()
				if err := s.SellAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellAvailableFlag\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "realExchange":
			if err := func() error {
				s.RealExchange.Reset()
				if err := s.RealExchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realExchange\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Etf")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Etf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Etf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1EtfResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1EtfResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instrument.Set {
			e.FieldStart("instrument")
			s.Instrument.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1EtfResponse = [1]string{
	0: "instrument",
}

// Decode decodes V1EtfResponse from json.
func (s *V1EtfResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1EtfResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrument":
			if err := func() error {
				s.Instrument.Reset()
				if err := s.Instrument.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrument\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1EtfResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1EtfResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1EtfResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1EtfsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1EtfsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1EtfsResponse = [1]string{
	0: "instruments",
}

// Decode decodes V1EtfsResponse from json.
func (s *V1EtfsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1EtfsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1Etf, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Etf
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1EtfsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1EtfsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1EtfsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1FavoriteInstrument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1FavoriteInstrument) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.InstrumentKind.Set {
			e.FieldStart("instrumentKind")
			s.InstrumentKind.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1FavoriteInstrument = [8]string{
	0: "figi",
	1: "ticker",
	2: "classCode",
	3: "isin",
	4: "instrumentType",
	5: "otcFlag",
	6: "apiTradeAvailableFlag",
	7: "instrumentKind",
}

// Decode decodes V1FavoriteInstrument from json.
func (s *V1FavoriteInstrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1FavoriteInstrument to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "instrumentKind":
			if err := func() error {
				s.InstrumentKind.Reset()
				if err := s.InstrumentKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentKind\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1FavoriteInstrument")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1FavoriteInstrument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1FavoriteInstrument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1FindInstrumentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1FindInstrumentRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1FindInstrumentRequest = [1]string{
	0: "query",
}

// Decode decodes V1FindInstrumentRequest from json.
func (s *V1FindInstrumentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1FindInstrumentRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1FindInstrumentRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1FindInstrumentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1FindInstrumentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1FindInstrumentResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1FindInstrumentResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1FindInstrumentResponse = [1]string{
	0: "instruments",
}

// Decode decodes V1FindInstrumentResponse from json.
func (s *V1FindInstrumentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1FindInstrumentResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1InstrumentShort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1InstrumentShort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1FindInstrumentResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1FindInstrumentResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1FindInstrumentResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Future) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Future) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Lot.Set {
			e.FieldStart("lot")
			s.Lot.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Klong.Set {
			e.FieldStart("klong")
			s.Klong.Encode(e)
		}
	}
	{
		if s.Kshort.Set {
			e.FieldStart("kshort")
			s.Kshort.Encode(e)
		}
	}
	{
		if s.Dlong.Set {
			e.FieldStart("dlong")
			s.Dlong.Encode(e)
		}
	}
	{
		if s.Dshort.Set {
			e.FieldStart("dshort")
			s.Dshort.Encode(e)
		}
	}
	{
		if s.DlongMin.Set {
			e.FieldStart("dlongMin")
			s.DlongMin.Encode(e)
		}
	}
	{
		if s.DshortMin.Set {
			e.FieldStart("dshortMin")
			s.DshortMin.Encode(e)
		}
	}
	{
		if s.ShortEnabledFlag.Set {
			e.FieldStart("shortEnabledFlag")
			s.ShortEnabledFlag.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.FirstTradeDate.Set {
			e.FieldStart("firstTradeDate")
			s.FirstTradeDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastTradeDate.Set {
			e.FieldStart("lastTradeDate")
			s.LastTradeDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FuturesType.Set {
			e.FieldStart("futuresType")
			s.FuturesType.Encode(e)
		}
	}
	{
		if s.AssetType.Set {
			e.FieldStart("assetType")
			s.AssetType.Encode(e)
		}
	}
	{
		if s.BasicAsset.Set {
			e.FieldStart("basicAsset")
			s.BasicAsset.Encode(e)
		}
	}
	{
		if s.BasicAssetSize.Set {
			e.FieldStart("basicAssetSize")
			s.BasicAssetSize.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
	{
		if s.Sector.Set {
			e.FieldStart("sector")
			s.Sector.Encode(e)
		}
	}
	{
		if s.ExpirationDate.Set {
			e.FieldStart("expirationDate")
			s.ExpirationDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.BuyAvailableFlag.Set {
			e.FieldStart("buyAvailableFlag")
			s.BuyAvailableFlag.Encode(e)
		}
	}
	{
		if s.SellAvailableFlag.Set {
			e.FieldStart("sellAvailableFlag")
			s.SellAvailableFlag.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.RealExchange.Set {
			e.FieldStart("realExchange")
			s.RealExchange.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.BasicAssetPositionUid.Set {
			e.FieldStart("basicAssetPositionUid")
			s.BasicAssetPositionUid.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1Future = [40]string{
	0:  "figi",
	1:  "ticker",
	2:  "classCode",
	3:  "lot",
	4:  "currency",
	5:  "klong",
	6:  "kshort",
	7:  "dlong",
	8:  "dshort",
	9:  "dlongMin",
	10: "dshortMin",
	11: "shortEnabledFlag",
	12: "name",
	13: "exchange",
	14: "firstTradeDate",
	15: "lastTradeDate",
	16: "futuresType",
	17: "assetType",
	18: "basicAsset",
	19: "basicAssetSize",
	20: "countryOfRisk",
	21: "countryOfRiskName",
	22: "sector",
	23: "expirationDate",
	24: "tradingStatus",
	25: "otcFlag",
	26: "buyAvailableFlag",
	27: "sellAvailableFlag",
	28: "minPriceIncrement",
	29: "apiTradeAvailableFlag",
	30: "uid",
	31: "realExchange",
	32: "positionUid",
	33: "basicAssetPositionUid",
	34: "forIisFlag",
	35: "forQualInvestorFlag",
	36: "weekendFlag",
	37: "blockedTcaFlag",
	38: "first1minCandleDate",
	39: "first1dayCandleDate",
}

// Decode decodes V1Future from json.
func (s *V1Future) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Future to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "lot":
			if err := func() error {
				s.Lot.Reset()
				if err := s.Lot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "klong":
			if err := func() error {
				s.Klong.Reset()
				if err := s.Klong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"klong\"")
			}
		case "kshort":
			if err := func() error {
				s.Kshort.Reset()
				if err := s.Kshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kshort\"")
			}
		case "dlong":
			if err := func() error {
				s.Dlong.Reset()
				if err := s.Dlong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlong\"")
			}
		case "dshort":
			if err := func() error {
				s.Dshort.Reset()
				if err := s.Dshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshort\"")
			}
		case "dlongMin":
			if err := func() error {
				s.DlongMin.Reset()
				if err := s.DlongMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlongMin\"")
			}
		case "dshortMin":
			if err := func() error {
				s.DshortMin.Reset()
				if err := s.DshortMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshortMin\"")
			}
		case "shortEnabledFlag":
			if err := func() error {
				s.ShortEnabledFlag.Reset()
				if err := s.ShortEnabledFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortEnabledFlag\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "firstTradeDate":
			if err := func() error {
				s.FirstTradeDate.Reset()
				if err := s.FirstTradeDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTradeDate\"")
			}
		case "lastTradeDate":
			if err := func() error {
				s.LastTradeDate.Reset()
				if err := s.LastTradeDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTradeDate\"")
			}
		case "futuresType":
			if err := func() error {
				s.FuturesType.Reset()
				if err := s.FuturesType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"futuresType\"")
			}
		case "assetType":
			if err := func() error {
				s.AssetType.Reset()
				if err := s.AssetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetType\"")
			}
		case "basicAsset":
			if err := func() error {
				s.BasicAsset.Reset()
				if err := s.BasicAsset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAsset\"")
			}
		case "basicAssetSize":
			if err := func() error {
				s.BasicAssetSize.Reset()
				if err := s.BasicAssetSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAssetSize\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		case "sector":
			if err := func() error {
				s.Sector.Reset()
				if err := s.Sector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sector\"")
			}
		case "expirationDate":
			if err := func() error {
				s.ExpirationDate.Reset()
				if err := s.ExpirationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationDate\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "buyAvailableFlag":
			if err := func() error {
				s.BuyAvailableFlag.Reset()
				if err := s.BuyAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyAvailableFlag\"")
			}
		case "sellAvailableFlag":
			if err := func() error {
				s.SellAvailableFlag.Reset()
				if err := s.SellAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellAvailableFlag\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "realExchange":
			if err := func() error {
				s.RealExchange.Reset()
				if err := s.RealExchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realExchange\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "basicAssetPositionUid":
			if err := func() error {
				s.BasicAssetPositionUid.Reset()
				if err := s.BasicAssetPositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAssetPositionUid\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Future")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Future) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Future) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1FutureResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1FutureResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instrument.Set {
			e.FieldStart("instrument")
			s.Instrument.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1FutureResponse = [1]string{
	0: "instrument",
}

// Decode decodes V1FutureResponse from json.
func (s *V1FutureResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1FutureResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrument":
			if err := func() error {
				s.Instrument.Reset()
				if err := s.Instrument.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrument\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1FutureResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1FutureResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1FutureResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1FuturesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1FuturesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1FuturesResponse = [1]string{
	0: "instruments",
}

// Decode decodes V1FuturesResponse from json.
func (s *V1FuturesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1FuturesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1Future, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Future
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1FuturesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1FuturesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1FuturesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GenerateBrokerReportRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GenerateBrokerReportRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1GenerateBrokerReportRequest = [3]string{
	0: "accountId",
	1: "from",
	2: "to",
}

// Decode decodes V1GenerateBrokerReportRequest from json.
func (s *V1GenerateBrokerReportRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GenerateBrokerReportRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GenerateBrokerReportRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GenerateBrokerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GenerateBrokerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GenerateBrokerReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GenerateBrokerReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GenerateBrokerReportResponse = [1]string{
	0: "taskId",
}

// Decode decodes V1GenerateBrokerReportResponse from json.
func (s *V1GenerateBrokerReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GenerateBrokerReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GenerateBrokerReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GenerateBrokerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GenerateBrokerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GenerateDividendsForeignIssuerReportRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GenerateDividendsForeignIssuerReportRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1GenerateDividendsForeignIssuerReportRequest = [3]string{
	0: "accountId",
	1: "from",
	2: "to",
}

// Decode decodes V1GenerateDividendsForeignIssuerReportRequest from json.
func (s *V1GenerateDividendsForeignIssuerReportRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GenerateDividendsForeignIssuerReportRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GenerateDividendsForeignIssuerReportRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GenerateDividendsForeignIssuerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GenerateDividendsForeignIssuerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GenerateDividendsForeignIssuerReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GenerateDividendsForeignIssuerReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GenerateDividendsForeignIssuerReportResponse = [1]string{
	0: "taskId",
}

// Decode decodes V1GenerateDividendsForeignIssuerReportResponse from json.
func (s *V1GenerateDividendsForeignIssuerReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GenerateDividendsForeignIssuerReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GenerateDividendsForeignIssuerReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GenerateDividendsForeignIssuerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GenerateDividendsForeignIssuerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetAccountsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetAccountsRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1GetAccountsRequest = [0]string{}

// Decode decodes V1GetAccountsRequest from json.
func (s *V1GetAccountsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetAccountsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetAccountsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetAccountsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetAccountsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetAccountsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetAccountsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Accounts != nil {
			e.FieldStart("accounts")
			e.ArrStart()
			for _, elem := range s.Accounts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetAccountsResponse = [1]string{
	0: "accounts",
}

// Decode decodes V1GetAccountsResponse from json.
func (s *V1GetAccountsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetAccountsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accounts":
			if err := func() error {
				s.Accounts = make([]V1Account, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Account
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Accounts = append(s.Accounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accounts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetAccountsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetAccountsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetAccountsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetAccruedInterestsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetAccruedInterestsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1GetAccruedInterestsRequest = [3]string{
	0: "figi",
	1: "from",
	2: "to",
}

// Decode decodes V1GetAccruedInterestsRequest from json.
func (s *V1GetAccruedInterestsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetAccruedInterestsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetAccruedInterestsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetAccruedInterestsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetAccruedInterestsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetAccruedInterestsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetAccruedInterestsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.AccruedInterests != nil {
			e.FieldStart("accruedInterests")
			e.ArrStart()
			for _, elem := range s.AccruedInterests {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetAccruedInterestsResponse = [1]string{
	0: "accruedInterests",
}

// Decode decodes V1GetAccruedInterestsResponse from json.
func (s *V1GetAccruedInterestsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetAccruedInterestsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accruedInterests":
			if err := func() error {
				s.AccruedInterests = make([]V1AccruedInterest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1AccruedInterest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AccruedInterests = append(s.AccruedInterests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accruedInterests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetAccruedInterestsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetAccruedInterestsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetAccruedInterestsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetBondCouponsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetBondCouponsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1GetBondCouponsRequest = [3]string{
	0: "figi",
	1: "from",
	2: "to",
}

// Decode decodes V1GetBondCouponsRequest from json.
func (s *V1GetBondCouponsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetBondCouponsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetBondCouponsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetBondCouponsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetBondCouponsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetBondCouponsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetBondCouponsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetBondCouponsResponse = [1]string{
	0: "events",
}

// Decode decodes V1GetBondCouponsResponse from json.
func (s *V1GetBondCouponsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetBondCouponsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "events":
			if err := func() error {
				s.Events = make([]V1Coupon, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Coupon
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetBondCouponsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetBondCouponsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetBondCouponsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetBrandRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetBrandRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetBrandRequest = [1]string{
	0: "id",
}

// Decode decodes V1GetBrandRequest from json.
func (s *V1GetBrandRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetBrandRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetBrandRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetBrandRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetBrandRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetBrandsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetBrandsRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1GetBrandsRequest = [0]string{}

// Decode decodes V1GetBrandsRequest from json.
func (s *V1GetBrandsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetBrandsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetBrandsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetBrandsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetBrandsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetBrandsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetBrandsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Brands != nil {
			e.FieldStart("brands")
			e.ArrStart()
			for _, elem := range s.Brands {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetBrandsResponse = [1]string{
	0: "brands",
}

// Decode decodes V1GetBrandsResponse from json.
func (s *V1GetBrandsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetBrandsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brands":
			if err := func() error {
				s.Brands = make([]V1Brand, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Brand
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Brands = append(s.Brands, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brands\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetBrandsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetBrandsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetBrandsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetBrokerReportRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetBrokerReportRequest) encodeFields(e *jx.Encoder) {
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetBrokerReportRequest = [2]string{
	0: "taskId",
	1: "page",
}

// Decode decodes V1GetBrokerReportRequest from json.
func (s *V1GetBrokerReportRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetBrokerReportRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetBrokerReportRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetBrokerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetBrokerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetBrokerReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetBrokerReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.BrokerReport != nil {
			e.FieldStart("brokerReport")
			e.ArrStart()
			for _, elem := range s.BrokerReport {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ItemsCount.Set {
			e.FieldStart("itemsCount")
			s.ItemsCount.Encode(e)
		}
	}
	{
		if s.PagesCount.Set {
			e.FieldStart("pagesCount")
			s.PagesCount.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetBrokerReportResponse = [4]string{
	0: "brokerReport",
	1: "itemsCount",
	2: "pagesCount",
	3: "page",
}

// Decode decodes V1GetBrokerReportResponse from json.
func (s *V1GetBrokerReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetBrokerReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "brokerReport":
			if err := func() error {
				s.BrokerReport = make([]V1BrokerReport, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1BrokerReport
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BrokerReport = append(s.BrokerReport, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerReport\"")
			}
		case "itemsCount":
			if err := func() error {
				s.ItemsCount.Reset()
				if err := s.ItemsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsCount\"")
			}
		case "pagesCount":
			if err := func() error {
				s.PagesCount.Reset()
				if err := s.PagesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagesCount\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetBrokerReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetBrokerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetBrokerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetCandlesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetCandlesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Interval.Set {
			e.FieldStart("interval")
			s.Interval.Encode(e)
		}
	}
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetCandlesRequest = [5]string{
	0: "figi",
	1: "from",
	2: "to",
	3: "interval",
	4: "instrumentId",
}

// Decode decodes V1GetCandlesRequest from json.
func (s *V1GetCandlesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetCandlesRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetCandlesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetCandlesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetCandlesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetCandlesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetCandlesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Candles != nil {
			e.FieldStart("candles")
			e.ArrStart()
			for _, elem := range s.Candles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetCandlesResponse = [1]string{
	0: "candles",
}

// Decode decodes V1GetCandlesResponse from json.
func (s *V1GetCandlesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetCandlesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "candles":
			if err := func() error {
				s.Candles = make([]V1HistoricCandle, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1HistoricCandle
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Candles = append(s.Candles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetCandlesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetCandlesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetCandlesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetClosePricesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetClosePricesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetClosePricesRequest = [1]string{
	0: "instruments",
}

// Decode decodes V1GetClosePricesRequest from json.
func (s *V1GetClosePricesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetClosePricesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1InstrumentClosePriceRequest, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1InstrumentClosePriceRequest
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetClosePricesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetClosePricesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetClosePricesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetClosePricesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetClosePricesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ClosePrices != nil {
			e.FieldStart("closePrices")
			e.ArrStart()
			for _, elem := range s.ClosePrices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetClosePricesResponse = [1]string{
	0: "closePrices",
}

// Decode decodes V1GetClosePricesResponse from json.
func (s *V1GetClosePricesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetClosePricesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "closePrices":
			if err := func() error {
				s.ClosePrices = make([]V1InstrumentClosePriceResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1InstrumentClosePriceResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ClosePrices = append(s.ClosePrices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closePrices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetClosePricesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetClosePricesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetClosePricesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetCountriesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetCountriesRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1GetCountriesRequest = [0]string{}

// Decode decodes V1GetCountriesRequest from json.
func (s *V1GetCountriesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetCountriesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetCountriesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetCountriesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetCountriesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetCountriesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetCountriesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Countries != nil {
			e.FieldStart("countries")
			e.ArrStart()
			for _, elem := range s.Countries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetCountriesResponse = [1]string{
	0: "countries",
}

// Decode decodes V1GetCountriesResponse from json.
func (s *V1GetCountriesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetCountriesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "countries":
			if err := func() error {
				s.Countries = make([]V1CountryResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1CountryResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Countries = append(s.Countries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetCountriesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetCountriesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetCountriesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetDividendsForeignIssuerReportRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetDividendsForeignIssuerReportRequest) encodeFields(e *jx.Encoder) {
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetDividendsForeignIssuerReportRequest = [2]string{
	0: "taskId",
	1: "page",
}

// Decode decodes V1GetDividendsForeignIssuerReportRequest from json.
func (s *V1GetDividendsForeignIssuerReportRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetDividendsForeignIssuerReportRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetDividendsForeignIssuerReportRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetDividendsForeignIssuerReportRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetDividendsForeignIssuerReportRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetDividendsForeignIssuerReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetDividendsForeignIssuerReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.DividendsForeignIssuerReport != nil {
			e.FieldStart("dividendsForeignIssuerReport")
			e.ArrStart()
			for _, elem := range s.DividendsForeignIssuerReport {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ItemsCount.Set {
			e.FieldStart("itemsCount")
			s.ItemsCount.Encode(e)
		}
	}
	{
		if s.PagesCount.Set {
			e.FieldStart("pagesCount")
			s.PagesCount.Encode(e)
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetDividendsForeignIssuerReportResponse = [4]string{
	0: "dividendsForeignIssuerReport",
	1: "itemsCount",
	2: "pagesCount",
	3: "page",
}

// Decode decodes V1GetDividendsForeignIssuerReportResponse from json.
func (s *V1GetDividendsForeignIssuerReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetDividendsForeignIssuerReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dividendsForeignIssuerReport":
			if err := func() error {
				s.DividendsForeignIssuerReport = make([]V1DividendsForeignIssuerReport, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1DividendsForeignIssuerReport
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DividendsForeignIssuerReport = append(s.DividendsForeignIssuerReport, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividendsForeignIssuerReport\"")
			}
		case "itemsCount":
			if err := func() error {
				s.ItemsCount.Reset()
				if err := s.ItemsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsCount\"")
			}
		case "pagesCount":
			if err := func() error {
				s.PagesCount.Reset()
				if err := s.PagesCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagesCount\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetDividendsForeignIssuerReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetDividendsForeignIssuerReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetDividendsForeignIssuerReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetDividendsForeignIssuerRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetDividendsForeignIssuerRequest) encodeFields(e *jx.Encoder) {
	{
		if s.GenerateDivForeignIssuerReport.Set {
			e.FieldStart("generateDivForeignIssuerReport")
			s.GenerateDivForeignIssuerReport.Encode(e)
		}
	}
	{
		if s.GetDivForeignIssuerReport.Set {
			e.FieldStart("getDivForeignIssuerReport")
			s.GetDivForeignIssuerReport.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetDividendsForeignIssuerRequest = [2]string{
	0: "generateDivForeignIssuerReport",
	1: "getDivForeignIssuerReport",
}

// Decode decodes V1GetDividendsForeignIssuerRequest from json.
func (s *V1GetDividendsForeignIssuerRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetDividendsForeignIssuerRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "generateDivForeignIssuerReport":
			if err := func() error {
				s.GenerateDivForeignIssuerReport.Reset()
				if err := s.GenerateDivForeignIssuerReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generateDivForeignIssuerReport\"")
			}
		case "getDivForeignIssuerReport":
			if err := func() error {
				s.GetDivForeignIssuerReport.Reset()
				if err := s.GetDivForeignIssuerReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getDivForeignIssuerReport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetDividendsForeignIssuerRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetDividendsForeignIssuerRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetDividendsForeignIssuerRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetDividendsForeignIssuerResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetDividendsForeignIssuerResponse) encodeFields(e *jx.Encoder) {
	{
		if s.GenerateDivForeignIssuerReportResponse.Set {
			e.FieldStart("generateDivForeignIssuerReportResponse")
			s.GenerateDivForeignIssuerReportResponse.Encode(e)
		}
	}
	{
		if s.DivForeignIssuerReport.Set {
			e.FieldStart("divForeignIssuerReport")
			s.DivForeignIssuerReport.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetDividendsForeignIssuerResponse = [2]string{
	0: "generateDivForeignIssuerReportResponse",
	1: "divForeignIssuerReport",
}

// Decode decodes V1GetDividendsForeignIssuerResponse from json.
func (s *V1GetDividendsForeignIssuerResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetDividendsForeignIssuerResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "generateDivForeignIssuerReportResponse":
			if err := func() error {
				s.GenerateDivForeignIssuerReportResponse.Reset()
				if err := s.GenerateDivForeignIssuerReportResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generateDivForeignIssuerReportResponse\"")
			}
		case "divForeignIssuerReport":
			if err := func() error {
				s.DivForeignIssuerReport.Reset()
				if err := s.DivForeignIssuerReport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"divForeignIssuerReport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetDividendsForeignIssuerResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetDividendsForeignIssuerResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetDividendsForeignIssuerResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetDividendsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetDividendsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1GetDividendsRequest = [3]string{
	0: "figi",
	1: "from",
	2: "to",
}

// Decode decodes V1GetDividendsRequest from json.
func (s *V1GetDividendsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetDividendsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetDividendsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetDividendsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetDividendsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetDividendsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetDividendsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Dividends != nil {
			e.FieldStart("dividends")
			e.ArrStart()
			for _, elem := range s.Dividends {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetDividendsResponse = [1]string{
	0: "dividends",
}

// Decode decodes V1GetDividendsResponse from json.
func (s *V1GetDividendsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetDividendsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dividends":
			if err := func() error {
				s.Dividends = make([]V1Dividend, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Dividend
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Dividends = append(s.Dividends, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dividends\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetDividendsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetDividendsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetDividendsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetFavoritesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetFavoritesRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1GetFavoritesRequest = [0]string{}

// Decode decodes V1GetFavoritesRequest from json.
func (s *V1GetFavoritesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetFavoritesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetFavoritesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetFavoritesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetFavoritesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetFavoritesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetFavoritesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.FavoriteInstruments != nil {
			e.FieldStart("favoriteInstruments")
			e.ArrStart()
			for _, elem := range s.FavoriteInstruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetFavoritesResponse = [1]string{
	0: "favoriteInstruments",
}

// Decode decodes V1GetFavoritesResponse from json.
func (s *V1GetFavoritesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetFavoritesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "favoriteInstruments":
			if err := func() error {
				s.FavoriteInstruments = make([]V1FavoriteInstrument, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1FavoriteInstrument
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FavoriteInstruments = append(s.FavoriteInstruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favoriteInstruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetFavoritesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetFavoritesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetFavoritesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetFuturesMarginRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetFuturesMarginRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetFuturesMarginRequest = [1]string{
	0: "figi",
}

// Decode decodes V1GetFuturesMarginRequest from json.
func (s *V1GetFuturesMarginRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetFuturesMarginRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetFuturesMarginRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetFuturesMarginRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetFuturesMarginRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetFuturesMarginResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetFuturesMarginResponse) encodeFields(e *jx.Encoder) {
	{
		if s.InitialMarginOnBuy.Set {
			e.FieldStart("initialMarginOnBuy")
			s.InitialMarginOnBuy.Encode(e)
		}
	}
	{
		if s.InitialMarginOnSell.Set {
			e.FieldStart("initialMarginOnSell")
			s.InitialMarginOnSell.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.MinPriceIncrementAmount.Set {
			e.FieldStart("minPriceIncrementAmount")
			s.MinPriceIncrementAmount.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetFuturesMarginResponse = [4]string{
	0: "initialMarginOnBuy",
	1: "initialMarginOnSell",
	2: "minPriceIncrement",
	3: "minPriceIncrementAmount",
}

// Decode decodes V1GetFuturesMarginResponse from json.
func (s *V1GetFuturesMarginResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetFuturesMarginResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "initialMarginOnBuy":
			if err := func() error {
				s.InitialMarginOnBuy.Reset()
				if err := s.InitialMarginOnBuy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialMarginOnBuy\"")
			}
		case "initialMarginOnSell":
			if err := func() error {
				s.InitialMarginOnSell.Reset()
				if err := s.InitialMarginOnSell.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialMarginOnSell\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "minPriceIncrementAmount":
			if err := func() error {
				s.MinPriceIncrementAmount.Reset()
				if err := s.MinPriceIncrementAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrementAmount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetFuturesMarginResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetFuturesMarginResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetFuturesMarginResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetInfoRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetInfoRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1GetInfoRequest = [0]string{}

// Decode decodes V1GetInfoRequest from json.
func (s *V1GetInfoRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetInfoRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetInfoRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetInfoRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetInfoRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetInfoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetInfoResponse) encodeFields(e *jx.Encoder) {
	{
		if s.PremStatus.Set {
			e.FieldStart("premStatus")
			s.PremStatus.Encode(e)
		}
	}
	{
		if s.QualStatus.Set {
			e.FieldStart("qualStatus")
			s.QualStatus.Encode(e)
		}
	}
	{
		if s.QualifiedForWorkWith != nil {
			e.FieldStart("qualifiedForWorkWith")
			e.ArrStart()
			for _, elem := range s.QualifiedForWorkWith {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tariff.Set {
			e.FieldStart("tariff")
			s.Tariff.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetInfoResponse = [4]string{
	0: "premStatus",
	1: "qualStatus",
	2: "qualifiedForWorkWith",
	3: "tariff",
}

// Decode decodes V1GetInfoResponse from json.
func (s *V1GetInfoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetInfoResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "premStatus":
			if err := func() error {
				s.PremStatus.Reset()
				if err := s.PremStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premStatus\"")
			}
		case "qualStatus":
			if err := func() error {
				s.QualStatus.Reset()
				if err := s.QualStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"qualStatus\"")
			}
		case "qualifiedForWorkWith":
			if err := func() error {
				s.QualifiedForWorkWith = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.QualifiedForWorkWith = append(s.QualifiedForWorkWith, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"qualifiedForWorkWith\"")
			}
		case "tariff":
			if err := func() error {
				s.Tariff.Reset()
				if err := s.Tariff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tariff\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetInfoResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetInfoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetInfoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetLastPricesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetLastPricesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi != nil {
			e.FieldStart("figi")
			e.ArrStart()
			for _, elem := range s.Figi {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InstrumentId != nil {
			e.FieldStart("instrumentId")
			e.ArrStart()
			for _, elem := range s.InstrumentId {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetLastPricesRequest = [2]string{
	0: "figi",
	1: "instrumentId",
}

// Decode decodes V1GetLastPricesRequest from json.
func (s *V1GetLastPricesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetLastPricesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Figi = append(s.Figi, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.InstrumentId = append(s.InstrumentId, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetLastPricesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetLastPricesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetLastPricesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetLastPricesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetLastPricesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.LastPrices != nil {
			e.FieldStart("lastPrices")
			e.ArrStart()
			for _, elem := range s.LastPrices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetLastPricesResponse = [1]string{
	0: "lastPrices",
}

// Decode decodes V1GetLastPricesResponse from json.
func (s *V1GetLastPricesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetLastPricesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastPrices":
			if err := func() error {
				s.LastPrices = make([]V1LastPrice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1LastPrice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LastPrices = append(s.LastPrices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastPrices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetLastPricesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetLastPricesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetLastPricesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetLastTradesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetLastTradesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetLastTradesRequest = [4]string{
	0: "figi",
	1: "from",
	2: "to",
	3: "instrumentId",
}

// Decode decodes V1GetLastTradesRequest from json.
func (s *V1GetLastTradesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetLastTradesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetLastTradesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetLastTradesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetLastTradesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetLastTradesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetLastTradesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Trades != nil {
			e.FieldStart("trades")
			e.ArrStart()
			for _, elem := range s.Trades {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetLastTradesResponse = [1]string{
	0: "trades",
}

// Decode decodes V1GetLastTradesResponse from json.
func (s *V1GetLastTradesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetLastTradesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trades":
			if err := func() error {
				s.Trades = make([]V1Trade, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Trade
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Trades = append(s.Trades, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trades\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetLastTradesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetLastTradesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetLastTradesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetMarginAttributesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetMarginAttributesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetMarginAttributesRequest = [1]string{
	0: "accountId",
}

// Decode decodes V1GetMarginAttributesRequest from json.
func (s *V1GetMarginAttributesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetMarginAttributesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetMarginAttributesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetMarginAttributesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetMarginAttributesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetMarginAttributesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetMarginAttributesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.LiquidPortfolio.Set {
			e.FieldStart("liquidPortfolio")
			s.LiquidPortfolio.Encode(e)
		}
	}
	{
		if s.StartingMargin.Set {
			e.FieldStart("startingMargin")
			s.StartingMargin.Encode(e)
		}
	}
	{
		if s.MinimalMargin.Set {
			e.FieldStart("minimalMargin")
			s.MinimalMargin.Encode(e)
		}
	}
	{
		if s.FundsSufficiencyLevel.Set {
			e.FieldStart("fundsSufficiencyLevel")
			s.FundsSufficiencyLevel.Encode(e)
		}
	}
	{
		if s.AmountOfMissingFunds.Set {
			e.FieldStart("amountOfMissingFunds")
			s.AmountOfMissingFunds.Encode(e)
		}
	}
	{
		if s.CorrectedMargin.Set {
			e.FieldStart("correctedMargin")
			s.CorrectedMargin.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetMarginAttributesResponse = [6]string{
	0: "liquidPortfolio",
	1: "startingMargin",
	2: "minimalMargin",
	3: "fundsSufficiencyLevel",
	4: "amountOfMissingFunds",
	5: "correctedMargin",
}

// Decode decodes V1GetMarginAttributesResponse from json.
func (s *V1GetMarginAttributesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetMarginAttributesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "liquidPortfolio":
			if err := func() error {
				s.LiquidPortfolio.Reset()
				if err := s.LiquidPortfolio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liquidPortfolio\"")
			}
		case "startingMargin":
			if err := func() error {
				s.StartingMargin.Reset()
				if err := s.StartingMargin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingMargin\"")
			}
		case "minimalMargin":
			if err := func() error {
				s.MinimalMargin.Reset()
				if err := s.MinimalMargin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimalMargin\"")
			}
		case "fundsSufficiencyLevel":
			if err := func() error {
				s.FundsSufficiencyLevel.Reset()
				if err := s.FundsSufficiencyLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundsSufficiencyLevel\"")
			}
		case "amountOfMissingFunds":
			if err := func() error {
				s.AmountOfMissingFunds.Reset()
				if err := s.AmountOfMissingFunds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amountOfMissingFunds\"")
			}
		case "correctedMargin":
			if err := func() error {
				s.CorrectedMargin.Reset()
				if err := s.CorrectedMargin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correctedMargin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetMarginAttributesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetMarginAttributesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetMarginAttributesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetOperationsByCursorRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetOperationsByCursorRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Cursor.Set {
			e.FieldStart("cursor")
			s.Cursor.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.OperationTypes != nil {
			e.FieldStart("operationTypes")
			e.ArrStart()
			for _, elem := range s.OperationTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.WithoutCommissions.Set {
			e.FieldStart("withoutCommissions")
			s.WithoutCommissions.Encode(e)
		}
	}
	{
		if s.WithoutTrades.Set {
			e.FieldStart("withoutTrades")
			s.WithoutTrades.Encode(e)
		}
	}
	{
		if s.WithoutOvernights.Set {
			e.FieldStart("withoutOvernights")
			s.WithoutOvernights.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetOperationsByCursorRequest = [11]string{
	0:  "accountId",
	1:  "instrumentId",
	2:  "from",
	3:  "to",
	4:  "cursor",
	5:  "limit",
	6:  "operationTypes",
	7:  "state",
	8:  "withoutCommissions",
	9:  "withoutTrades",
	10: "withoutOvernights",
}

// Decode decodes V1GetOperationsByCursorRequest from json.
func (s *V1GetOperationsByCursorRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetOperationsByCursorRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "cursor":
			if err := func() error {
				s.Cursor.Reset()
				if err := s.Cursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "operationTypes":
			if err := func() error {
				s.OperationTypes = make([]V1OperationType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1OperationType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OperationTypes = append(s.OperationTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationTypes\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "withoutCommissions":
			if err := func() error {
				s.WithoutCommissions.Reset()
				if err := s.WithoutCommissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withoutCommissions\"")
			}
		case "withoutTrades":
			if err := func() error {
				s.WithoutTrades.Reset()
				if err := s.WithoutTrades.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withoutTrades\"")
			}
		case "withoutOvernights":
			if err := func() error {
				s.WithoutOvernights.Reset()
				if err := s.WithoutOvernights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withoutOvernights\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetOperationsByCursorRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetOperationsByCursorRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetOperationsByCursorRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetOperationsByCursorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetOperationsByCursorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.HasNext.Set {
			e.FieldStart("hasNext")
			s.HasNext.Encode(e)
		}
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("nextCursor")
			s.NextCursor.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetOperationsByCursorResponse = [3]string{
	0: "hasNext",
	1: "nextCursor",
	2: "items",
}

// Decode decodes V1GetOperationsByCursorResponse from json.
func (s *V1GetOperationsByCursorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetOperationsByCursorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hasNext":
			if err := func() error {
				s.HasNext.Reset()
				if err := s.HasNext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasNext\"")
			}
		case "nextCursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextCursor\"")
			}
		case "items":
			if err := func() error {
				s.Items = make([]V1OperationItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1OperationItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetOperationsByCursorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetOperationsByCursorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetOperationsByCursorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetOrderBookRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetOrderBookRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Depth.Set {
			e.FieldStart("depth")
			s.Depth.Encode(e)
		}
	}
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetOrderBookRequest = [3]string{
	0: "figi",
	1: "depth",
	2: "instrumentId",
}

// Decode decodes V1GetOrderBookRequest from json.
func (s *V1GetOrderBookRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetOrderBookRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "depth":
			if err := func() error {
				s.Depth.Reset()
				if err := s.Depth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depth\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetOrderBookRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetOrderBookRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetOrderBookRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetOrderBookResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetOrderBookResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Depth.Set {
			e.FieldStart("depth")
			s.Depth.Encode(e)
		}
	}
	{
		if s.Bids != nil {
			e.FieldStart("bids")
			e.ArrStart()
			for _, elem := range s.Bids {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Asks != nil {
			e.FieldStart("asks")
			e.ArrStart()
			for _, elem := range s.Asks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastPrice.Set {
			e.FieldStart("lastPrice")
			s.LastPrice.Encode(e)
		}
	}
	{
		if s.ClosePrice.Set {
			e.FieldStart("closePrice")
			s.ClosePrice.Encode(e)
		}
	}
	{
		if s.LimitUp.Set {
			e.FieldStart("limitUp")
			s.LimitUp.Encode(e)
		}
	}
	{
		if s.LimitDown.Set {
			e.FieldStart("limitDown")
			s.LimitDown.Encode(e)
		}
	}
	{
		if s.LastPriceTs.Set {
			e.FieldStart("lastPriceTs")
			s.LastPriceTs.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ClosePriceTs.Set {
			e.FieldStart("closePriceTs")
			s.ClosePriceTs.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OrderbookTs.Set {
			e.FieldStart("orderbookTs")
			s.OrderbookTs.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetOrderBookResponse = [12]string{
	0:  "figi",
	1:  "depth",
	2:  "bids",
	3:  "asks",
	4:  "lastPrice",
	5:  "closePrice",
	6:  "limitUp",
	7:  "limitDown",
	8:  "lastPriceTs",
	9:  "closePriceTs",
	10: "orderbookTs",
	11: "instrumentUid",
}

// Decode decodes V1GetOrderBookResponse from json.
func (s *V1GetOrderBookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetOrderBookResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "depth":
			if err := func() error {
				s.Depth.Reset()
				if err := s.Depth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depth\"")
			}
		case "bids":
			if err := func() error {
				s.Bids = make([]V1Order, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Order
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bids = append(s.Bids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bids\"")
			}
		case "asks":
			if err := func() error {
				s.Asks = make([]V1Order, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Order
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Asks = append(s.Asks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"asks\"")
			}
		case "lastPrice":
			if err := func() error {
				s.LastPrice.Reset()
				if err := s.LastPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastPrice\"")
			}
		case "closePrice":
			if err := func() error {
				s.ClosePrice.Reset()
				if err := s.ClosePrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closePrice\"")
			}
		case "limitUp":
			if err := func() error {
				s.LimitUp.Reset()
				if err := s.LimitUp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitUp\"")
			}
		case "limitDown":
			if err := func() error {
				s.LimitDown.Reset()
				if err := s.LimitDown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitDown\"")
			}
		case "lastPriceTs":
			if err := func() error {
				s.LastPriceTs.Reset()
				if err := s.LastPriceTs.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastPriceTs\"")
			}
		case "closePriceTs":
			if err := func() error {
				s.ClosePriceTs.Reset()
				if err := s.ClosePriceTs.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closePriceTs\"")
			}
		case "orderbookTs":
			if err := func() error {
				s.OrderbookTs.Reset()
				if err := s.OrderbookTs.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderbookTs\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetOrderBookResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetOrderBookResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetOrderBookResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetOrderStateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetOrderStateRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.OrderId.Set {
			e.FieldStart("orderId")
			s.OrderId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetOrderStateRequest = [2]string{
	0: "accountId",
	1: "orderId",
}

// Decode decodes V1GetOrderStateRequest from json.
func (s *V1GetOrderStateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetOrderStateRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "orderId":
			if err := func() error {
				s.OrderId.Reset()
				if err := s.OrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetOrderStateRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetOrderStateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetOrderStateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetOrdersRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetOrdersRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetOrdersRequest = [1]string{
	0: "accountId",
}

// Decode decodes V1GetOrdersRequest from json.
func (s *V1GetOrdersRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetOrdersRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetOrdersRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetOrdersRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetOrdersRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetOrdersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetOrdersResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Orders != nil {
			e.FieldStart("orders")
			e.ArrStart()
			for _, elem := range s.Orders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetOrdersResponse = [1]string{
	0: "orders",
}

// Decode decodes V1GetOrdersResponse from json.
func (s *V1GetOrdersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetOrdersResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orders":
			if err := func() error {
				s.Orders = make([]V1OrderState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1OrderState
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Orders = append(s.Orders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetOrdersResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetOrdersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetOrdersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetStopOrdersRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetStopOrdersRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetStopOrdersRequest = [1]string{
	0: "accountId",
}

// Decode decodes V1GetStopOrdersRequest from json.
func (s *V1GetStopOrdersRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetStopOrdersRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetStopOrdersRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetStopOrdersRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetStopOrdersRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetStopOrdersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetStopOrdersResponse) encodeFields(e *jx.Encoder) {
	{
		if s.StopOrders != nil {
			e.FieldStart("stopOrders")
			e.ArrStart()
			for _, elem := range s.StopOrders {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetStopOrdersResponse = [1]string{
	0: "stopOrders",
}

// Decode decodes V1GetStopOrdersResponse from json.
func (s *V1GetStopOrdersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetStopOrdersResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stopOrders":
			if err := func() error {
				s.StopOrders = make([]V1StopOrder, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1StopOrder
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StopOrders = append(s.StopOrders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopOrders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetStopOrdersResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetStopOrdersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetStopOrdersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetTradingStatusRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetTradingStatusRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetTradingStatusRequest = [2]string{
	0: "figi",
	1: "instrumentId",
}

// Decode decodes V1GetTradingStatusRequest from json.
func (s *V1GetTradingStatusRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetTradingStatusRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetTradingStatusRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetTradingStatusRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetTradingStatusRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetTradingStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetTradingStatusResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.LimitOrderAvailableFlag.Set {
			e.FieldStart("limitOrderAvailableFlag")
			s.LimitOrderAvailableFlag.Encode(e)
		}
	}
	{
		if s.MarketOrderAvailableFlag.Set {
			e.FieldStart("marketOrderAvailableFlag")
			s.MarketOrderAvailableFlag.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1GetTradingStatusResponse = [6]string{
	0: "figi",
	1: "tradingStatus",
	2: "limitOrderAvailableFlag",
	3: "marketOrderAvailableFlag",
	4: "apiTradeAvailableFlag",
	5: "instrumentUid",
}

// Decode decodes V1GetTradingStatusResponse from json.
func (s *V1GetTradingStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetTradingStatusResponse to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "limitOrderAvailableFlag":
			if err := func() error {
				s.LimitOrderAvailableFlag.Reset()
				if err := s.LimitOrderAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitOrderAvailableFlag\"")
			}
		case "marketOrderAvailableFlag":
			if err := func() error {
				s.MarketOrderAvailableFlag.Reset()
				if err := s.MarketOrderAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"marketOrderAvailableFlag\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetTradingStatusResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetTradingStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetTradingStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetTradingStatusesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetTradingStatusesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.InstrumentId != nil {
			e.FieldStart("instrumentId")
			e.ArrStart()
			for _, elem := range s.InstrumentId {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetTradingStatusesRequest = [1]string{
	0: "instrumentId",
}

// Decode decodes V1GetTradingStatusesRequest from json.
func (s *V1GetTradingStatusesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetTradingStatusesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrumentId":
			if err := func() error {
				s.InstrumentId = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.InstrumentId = append(s.InstrumentId, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetTradingStatusesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetTradingStatusesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetTradingStatusesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetTradingStatusesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetTradingStatusesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.TradingStatuses != nil {
			e.FieldStart("tradingStatuses")
			e.ArrStart()
			for _, elem := range s.TradingStatuses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetTradingStatusesResponse = [1]string{
	0: "tradingStatuses",
}

// Decode decodes V1GetTradingStatusesResponse from json.
func (s *V1GetTradingStatusesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetTradingStatusesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tradingStatuses":
			if err := func() error {
				s.TradingStatuses = make([]V1GetTradingStatusResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1GetTradingStatusResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TradingStatuses = append(s.TradingStatuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatuses\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetTradingStatusesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetTradingStatusesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetTradingStatusesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetUserTariffRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetUserTariffRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1GetUserTariffRequest = [0]string{}

// Decode decodes V1GetUserTariffRequest from json.
func (s *V1GetUserTariffRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetUserTariffRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetUserTariffRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetUserTariffRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetUserTariffRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1GetUserTariffResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1GetUserTariffResponse) encodeFields(e *jx.Encoder) {
	{
		if s.UnaryLimits != nil {
			e.FieldStart("unaryLimits")
			e.ArrStart()
			for _, elem := range s.UnaryLimits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.StreamLimits != nil {
			e.FieldStart("streamLimits")
			e.ArrStart()
			for _, elem := range s.StreamLimits {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1GetUserTariffResponse = [2]string{
	0: "unaryLimits",
	1: "streamLimits",
}

// Decode decodes V1GetUserTariffResponse from json.
func (s *V1GetUserTariffResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1GetUserTariffResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unaryLimits":
			if err := func() error {
				s.UnaryLimits = make([]V1UnaryLimit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1UnaryLimit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UnaryLimits = append(s.UnaryLimits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unaryLimits\"")
			}
		case "streamLimits":
			if err := func() error {
				s.StreamLimits = make([]V1StreamLimit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1StreamLimit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.StreamLimits = append(s.StreamLimits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamLimits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1GetUserTariffResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1GetUserTariffResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1GetUserTariffResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1HistoricCandle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1HistoricCandle) encodeFields(e *jx.Encoder) {
	{
		if s.Open.Set {
			e.FieldStart("open")
			s.Open.Encode(e)
		}
	}
	{
		if s.High.Set {
			e.FieldStart("high")
			s.High.Encode(e)
		}
	}
	{
		if s.Low.Set {
			e.FieldStart("low")
			s.Low.Encode(e)
		}
	}
	{
		if s.Close.Set {
			e.FieldStart("close")
			s.Close.Encode(e)
		}
	}
	{
		if s.Volume.Set {
			e.FieldStart("volume")
			s.Volume.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IsComplete.Set {
			e.FieldStart("isComplete")
			s.IsComplete.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1HistoricCandle = [7]string{
	0: "open",
	1: "high",
	2: "low",
	3: "close",
	4: "volume",
	5: "time",
	6: "isComplete",
}

// Decode decodes V1HistoricCandle from json.
func (s *V1HistoricCandle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1HistoricCandle to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "open":
			if err := func() error {
				s.Open.Reset()
				if err := s.Open.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open\"")
			}
		case "high":
			if err := func() error {
				s.High.Reset()
				if err := s.High.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"high\"")
			}
		case "low":
			if err := func() error {
				s.Low.Reset()
				if err := s.Low.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"low\"")
			}
		case "close":
			if err := func() error {
				s.Close.Reset()
				if err := s.Close.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"close\"")
			}
		case "volume":
			if err := func() error {
				s.Volume.Reset()
				if err := s.Volume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "isComplete":
			if err := func() error {
				s.IsComplete.Reset()
				if err := s.IsComplete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isComplete\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1HistoricCandle")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1HistoricCandle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1HistoricCandle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Instrument) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Instrument) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.Lot.Set {
			e.FieldStart("lot")
			s.Lot.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Klong.Set {
			e.FieldStart("klong")
			s.Klong.Encode(e)
		}
	}
	{
		if s.Kshort.Set {
			e.FieldStart("kshort")
			s.Kshort.Encode(e)
		}
	}
	{
		if s.Dlong.Set {
			e.FieldStart("dlong")
			s.Dlong.Encode(e)
		}
	}
	{
		if s.Dshort.Set {
			e.FieldStart("dshort")
			s.Dshort.Encode(e)
		}
	}
	{
		if s.DlongMin.Set {
			e.FieldStart("dlongMin")
			s.DlongMin.Encode(e)
		}
	}
	{
		if s.DshortMin.Set {
			e.FieldStart("dshortMin")
			s.DshortMin.Encode(e)
		}
	}
	{
		if s.ShortEnabledFlag.Set {
			e.FieldStart("shortEnabledFlag")
			s.ShortEnabledFlag.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.BuyAvailableFlag.Set {
			e.FieldStart("buyAvailableFlag")
			s.BuyAvailableFlag.Encode(e)
		}
	}
	{
		if s.SellAvailableFlag.Set {
			e.FieldStart("sellAvailableFlag")
			s.SellAvailableFlag.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.RealExchange.Set {
			e.FieldStart("realExchange")
			s.RealExchange.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
	{
		if s.InstrumentKind.Set {
			e.FieldStart("instrumentKind")
			s.InstrumentKind.Encode(e)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1Instrument = [34]string{
	0:  "figi",
	1:  "ticker",
	2:  "classCode",
	3:  "isin",
	4:  "lot",
	5:  "currency",
	6:  "klong",
	7:  "kshort",
	8:  "dlong",
	9:  "dshort",
	10: "dlongMin",
	11: "dshortMin",
	12: "shortEnabledFlag",
	13: "name",
	14: "exchange",
	15: "countryOfRisk",
	16: "countryOfRiskName",
	17: "instrumentType",
	18: "tradingStatus",
	19: "otcFlag",
	20: "buyAvailableFlag",
	21: "sellAvailableFlag",
	22: "minPriceIncrement",
	23: "apiTradeAvailableFlag",
	24: "uid",
	25: "realExchange",
	26: "positionUid",
	27: "forIisFlag",
	28: "forQualInvestorFlag",
	29: "weekendFlag",
	30: "blockedTcaFlag",
	31: "instrumentKind",
	32: "first1minCandleDate",
	33: "first1dayCandleDate",
}

// Decode decodes V1Instrument from json.
func (s *V1Instrument) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Instrument to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "lot":
			if err := func() error {
				s.Lot.Reset()
				if err := s.Lot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "klong":
			if err := func() error {
				s.Klong.Reset()
				if err := s.Klong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"klong\"")
			}
		case "kshort":
			if err := func() error {
				s.Kshort.Reset()
				if err := s.Kshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kshort\"")
			}
		case "dlong":
			if err := func() error {
				s.Dlong.Reset()
				if err := s.Dlong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlong\"")
			}
		case "dshort":
			if err := func() error {
				s.Dshort.Reset()
				if err := s.Dshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshort\"")
			}
		case "dlongMin":
			if err := func() error {
				s.DlongMin.Reset()
				if err := s.DlongMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlongMin\"")
			}
		case "dshortMin":
			if err := func() error {
				s.DshortMin.Reset()
				if err := s.DshortMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshortMin\"")
			}
		case "shortEnabledFlag":
			if err := func() error {
				s.ShortEnabledFlag.Reset()
				if err := s.ShortEnabledFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortEnabledFlag\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "buyAvailableFlag":
			if err := func() error {
				s.BuyAvailableFlag.Reset()
				if err := s.BuyAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyAvailableFlag\"")
			}
		case "sellAvailableFlag":
			if err := func() error {
				s.SellAvailableFlag.Reset()
				if err := s.SellAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellAvailableFlag\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "realExchange":
			if err := func() error {
				s.RealExchange.Reset()
				if err := s.RealExchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realExchange\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		case "instrumentKind":
			if err := func() error {
				s.InstrumentKind.Reset()
				if err := s.InstrumentKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentKind\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Instrument")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Instrument) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Instrument) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1InstrumentClosePriceRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1InstrumentClosePriceRequest) encodeFields(e *jx.Encoder) {
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1InstrumentClosePriceRequest = [1]string{
	0: "instrumentId",
}

// Decode decodes V1InstrumentClosePriceRequest from json.
func (s *V1InstrumentClosePriceRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentClosePriceRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1InstrumentClosePriceRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1InstrumentClosePriceRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentClosePriceRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1InstrumentClosePriceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1InstrumentClosePriceResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1InstrumentClosePriceResponse = [4]string{
	0: "figi",
	1: "instrumentUid",
	2: "price",
	3: "time",
}

// Decode decodes V1InstrumentClosePriceResponse from json.
func (s *V1InstrumentClosePriceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentClosePriceResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1InstrumentClosePriceResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1InstrumentClosePriceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentClosePriceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1InstrumentIdType as json.
func (s V1InstrumentIdType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1InstrumentIdType from json.
func (s *V1InstrumentIdType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentIdType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1InstrumentIdType(v) {
	case V1InstrumentIdTypeINSTRUMENTIDUNSPECIFIED:
		*s = V1InstrumentIdTypeINSTRUMENTIDUNSPECIFIED
	case V1InstrumentIdTypeINSTRUMENTIDTYPEFIGI:
		*s = V1InstrumentIdTypeINSTRUMENTIDTYPEFIGI
	case V1InstrumentIdTypeINSTRUMENTIDTYPETICKER:
		*s = V1InstrumentIdTypeINSTRUMENTIDTYPETICKER
	case V1InstrumentIdTypeINSTRUMENTIDTYPEUID:
		*s = V1InstrumentIdTypeINSTRUMENTIDTYPEUID
	case V1InstrumentIdTypeINSTRUMENTIDTYPEPOSITIONUID:
		*s = V1InstrumentIdTypeINSTRUMENTIDTYPEPOSITIONUID
	default:
		*s = V1InstrumentIdType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1InstrumentIdType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentIdType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1InstrumentLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1InstrumentLink) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1InstrumentLink = [2]string{
	0: "type",
	1: "instrumentUid",
}

// Decode decodes V1InstrumentLink from json.
func (s *V1InstrumentLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentLink to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1InstrumentLink")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1InstrumentLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1InstrumentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1InstrumentRequest) encodeFields(e *jx.Encoder) {
	{
		if s.IdType.Set {
			e.FieldStart("idType")
			s.IdType.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1InstrumentRequest = [3]string{
	0: "idType",
	1: "classCode",
	2: "id",
}

// Decode decodes V1InstrumentRequest from json.
func (s *V1InstrumentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "idType":
			if err := func() error {
				s.IdType.Reset()
				if err := s.IdType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idType\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1InstrumentRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1InstrumentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1InstrumentResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1InstrumentResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instrument.Set {
			e.FieldStart("instrument")
			s.Instrument.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1InstrumentResponse = [1]string{
	0: "instrument",
}

// Decode decodes V1InstrumentResponse from json.
func (s *V1InstrumentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrument":
			if err := func() error {
				s.Instrument.Reset()
				if err := s.Instrument.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrument\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1InstrumentResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1InstrumentResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1InstrumentShort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1InstrumentShort) encodeFields(e *jx.Encoder) {
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.InstrumentKind.Set {
			e.FieldStart("instrumentKind")
			s.InstrumentKind.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1InstrumentShort = [16]string{
	0:  "isin",
	1:  "figi",
	2:  "ticker",
	3:  "classCode",
	4:  "instrumentType",
	5:  "name",
	6:  "uid",
	7:  "positionUid",
	8:  "instrumentKind",
	9:  "apiTradeAvailableFlag",
	10: "forIisFlag",
	11: "first1minCandleDate",
	12: "first1dayCandleDate",
	13: "forQualInvestorFlag",
	14: "weekendFlag",
	15: "blockedTcaFlag",
}

// Decode decodes V1InstrumentShort from json.
func (s *V1InstrumentShort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentShort to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "instrumentKind":
			if err := func() error {
				s.InstrumentKind.Reset()
				if err := s.InstrumentKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentKind\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1InstrumentShort")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1InstrumentShort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentShort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1InstrumentStatus as json.
func (s V1InstrumentStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1InstrumentStatus from json.
func (s *V1InstrumentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1InstrumentStatus(v) {
	case V1InstrumentStatusINSTRUMENTSTATUSUNSPECIFIED:
		*s = V1InstrumentStatusINSTRUMENTSTATUSUNSPECIFIED
	case V1InstrumentStatusINSTRUMENTSTATUSBASE:
		*s = V1InstrumentStatusINSTRUMENTSTATUSBASE
	case V1InstrumentStatusINSTRUMENTSTATUSALL:
		*s = V1InstrumentStatusINSTRUMENTSTATUSALL
	default:
		*s = V1InstrumentStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1InstrumentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1InstrumentType as json.
func (s V1InstrumentType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1InstrumentType from json.
func (s *V1InstrumentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1InstrumentType(v) {
	case V1InstrumentTypeINSTRUMENTTYPEUNSPECIFIED:
		*s = V1InstrumentTypeINSTRUMENTTYPEUNSPECIFIED
	case V1InstrumentTypeINSTRUMENTTYPEBOND:
		*s = V1InstrumentTypeINSTRUMENTTYPEBOND
	case V1InstrumentTypeINSTRUMENTTYPESHARE:
		*s = V1InstrumentTypeINSTRUMENTTYPESHARE
	case V1InstrumentTypeINSTRUMENTTYPECURRENCY:
		*s = V1InstrumentTypeINSTRUMENTTYPECURRENCY
	case V1InstrumentTypeINSTRUMENTTYPEETF:
		*s = V1InstrumentTypeINSTRUMENTTYPEETF
	case V1InstrumentTypeINSTRUMENTTYPEFUTURES:
		*s = V1InstrumentTypeINSTRUMENTTYPEFUTURES
	case V1InstrumentTypeINSTRUMENTTYPESP:
		*s = V1InstrumentTypeINSTRUMENTTYPESP
	case V1InstrumentTypeINSTRUMENTTYPEOPTION:
		*s = V1InstrumentTypeINSTRUMENTTYPEOPTION
	case V1InstrumentTypeINSTRUMENTTYPECLEARINGCERTIFICATE:
		*s = V1InstrumentTypeINSTRUMENTTYPECLEARINGCERTIFICATE
	default:
		*s = V1InstrumentType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1InstrumentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1InstrumentsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1InstrumentsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.InstrumentStatus.Set {
			e.FieldStart("instrumentStatus")
			s.InstrumentStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1InstrumentsRequest = [1]string{
	0: "instrumentStatus",
}

// Decode decodes V1InstrumentsRequest from json.
func (s *V1InstrumentsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1InstrumentsRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrumentStatus":
			if err := func() error {
				s.InstrumentStatus.Reset()
				if err := s.InstrumentStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1InstrumentsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1InstrumentsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1InstrumentsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1LastPrice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1LastPrice) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1LastPrice = [4]string{
	0: "figi",
	1: "price",
	2: "time",
	3: "instrumentUid",
}

// Decode decodes V1LastPrice from json.
func (s *V1LastPrice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1LastPrice to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1LastPrice")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1LastPrice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1LastPrice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1MoneyValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1MoneyValue) encodeFields(e *jx.Encoder) {
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Units.Set {
			e.FieldStart("units")
			s.Units.Encode(e)
		}
	}
	{
		if s.Nano.Set {
			e.FieldStart("nano")
			s.Nano.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1MoneyValue = [3]string{
	0: "currency",
	1: "units",
	2: "nano",
}

// Decode decodes V1MoneyValue from json.
func (s *V1MoneyValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1MoneyValue to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "units":
			if err := func() error {
				s.Units.Reset()
				if err := s.Units.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"units\"")
			}
		case "nano":
			if err := func() error {
				s.Nano.Reset()
				if err := s.Nano.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nano\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1MoneyValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1MoneyValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1MoneyValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OpenSandboxAccountRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OpenSandboxAccountRequest) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfV1OpenSandboxAccountRequest = [0]string{}

// Decode decodes V1OpenSandboxAccountRequest from json.
func (s *V1OpenSandboxAccountRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OpenSandboxAccountRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OpenSandboxAccountRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OpenSandboxAccountRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OpenSandboxAccountRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OpenSandboxAccountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OpenSandboxAccountResponse) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OpenSandboxAccountResponse = [1]string{
	0: "accountId",
}

// Decode decodes V1OpenSandboxAccountResponse from json.
func (s *V1OpenSandboxAccountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OpenSandboxAccountResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OpenSandboxAccountResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OpenSandboxAccountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OpenSandboxAccountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Operation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Operation) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ParentOperationId.Set {
			e.FieldStart("parentOperationId")
			s.ParentOperationId.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Payment.Set {
			e.FieldStart("payment")
			s.Payment.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.QuantityRest.Set {
			e.FieldStart("quantityRest")
			s.QuantityRest.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.OperationType.Set {
			e.FieldStart("operationType")
			s.OperationType.Encode(e)
		}
	}
	{
		if s.Trades != nil {
			e.FieldStart("trades")
			e.ArrStart()
			for _, elem := range s.Trades {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AssetUid.Set {
			e.FieldStart("assetUid")
			s.AssetUid.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Operation = [17]string{
	0:  "id",
	1:  "parentOperationId",
	2:  "currency",
	3:  "payment",
	4:  "price",
	5:  "state",
	6:  "quantity",
	7:  "quantityRest",
	8:  "figi",
	9:  "instrumentType",
	10: "date",
	11: "type",
	12: "operationType",
	13: "trades",
	14: "assetUid",
	15: "positionUid",
	16: "instrumentUid",
}

// Decode decodes V1Operation from json.
func (s *V1Operation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Operation to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "parentOperationId":
			if err := func() error {
				s.ParentOperationId.Reset()
				if err := s.ParentOperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentOperationId\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "payment":
			if err := func() error {
				s.Payment.Reset()
				if err := s.Payment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "quantityRest":
			if err := func() error {
				s.QuantityRest.Reset()
				if err := s.QuantityRest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantityRest\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "operationType":
			if err := func() error {
				s.OperationType.Reset()
				if err := s.OperationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationType\"")
			}
		case "trades":
			if err := func() error {
				s.Trades = make([]V1OperationTrade, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1OperationTrade
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Trades = append(s.Trades, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trades\"")
			}
		case "assetUid":
			if err := func() error {
				s.AssetUid.Reset()
				if err := s.AssetUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetUid\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Operation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Operation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Operation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OperationItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OperationItem) encodeFields(e *jx.Encoder) {
	{
		if s.Cursor.Set {
			e.FieldStart("cursor")
			s.Cursor.Encode(e)
		}
	}
	{
		if s.BrokerAccountId.Set {
			e.FieldStart("brokerAccountId")
			s.BrokerAccountId.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ParentOperationId.Set {
			e.FieldStart("parentOperationId")
			s.ParentOperationId.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.InstrumentKind.Set {
			e.FieldStart("instrumentKind")
			s.InstrumentKind.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.Payment.Set {
			e.FieldStart("payment")
			s.Payment.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Commission.Set {
			e.FieldStart("commission")
			s.Commission.Encode(e)
		}
	}
	{
		if s.Yield.Set {
			e.FieldStart("yield")
			s.Yield.Encode(e)
		}
	}
	{
		if s.YieldRelative.Set {
			e.FieldStart("yieldRelative")
			s.YieldRelative.Encode(e)
		}
	}
	{
		if s.AccruedInt.Set {
			e.FieldStart("accruedInt")
			s.AccruedInt.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.QuantityRest.Set {
			e.FieldStart("quantityRest")
			s.QuantityRest.Encode(e)
		}
	}
	{
		if s.QuantityDone.Set {
			e.FieldStart("quantityDone")
			s.QuantityDone.Encode(e)
		}
	}
	{
		if s.CancelDateTime.Set {
			e.FieldStart("cancelDateTime")
			s.CancelDateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CancelReason.Set {
			e.FieldStart("cancelReason")
			s.CancelReason.Encode(e)
		}
	}
	{
		if s.TradesInfo.Set {
			e.FieldStart("tradesInfo")
			s.TradesInfo.Encode(e)
		}
	}
	{
		if s.AssetUid.Set {
			e.FieldStart("assetUid")
			s.AssetUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OperationItem = [27]string{
	0:  "cursor",
	1:  "brokerAccountId",
	2:  "id",
	3:  "parentOperationId",
	4:  "name",
	5:  "date",
	6:  "type",
	7:  "description",
	8:  "state",
	9:  "instrumentUid",
	10: "figi",
	11: "instrumentType",
	12: "instrumentKind",
	13: "positionUid",
	14: "payment",
	15: "price",
	16: "commission",
	17: "yield",
	18: "yieldRelative",
	19: "accruedInt",
	20: "quantity",
	21: "quantityRest",
	22: "quantityDone",
	23: "cancelDateTime",
	24: "cancelReason",
	25: "tradesInfo",
	26: "assetUid",
}

// Decode decodes V1OperationItem from json.
func (s *V1OperationItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationItem to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cursor":
			if err := func() error {
				s.Cursor.Reset()
				if err := s.Cursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "brokerAccountId":
			if err := func() error {
				s.BrokerAccountId.Reset()
				if err := s.BrokerAccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brokerAccountId\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "parentOperationId":
			if err := func() error {
				s.ParentOperationId.Reset()
				if err := s.ParentOperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentOperationId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "instrumentKind":
			if err := func() error {
				s.InstrumentKind.Reset()
				if err := s.InstrumentKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentKind\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "payment":
			if err := func() error {
				s.Payment.Reset()
				if err := s.Payment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "commission":
			if err := func() error {
				s.Commission.Reset()
				if err := s.Commission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commission\"")
			}
		case "yield":
			if err := func() error {
				s.Yield.Reset()
				if err := s.Yield.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yield\"")
			}
		case "yieldRelative":
			if err := func() error {
				s.YieldRelative.Reset()
				if err := s.YieldRelative.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yieldRelative\"")
			}
		case "accruedInt":
			if err := func() error {
				s.AccruedInt.Reset()
				if err := s.AccruedInt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accruedInt\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "quantityRest":
			if err := func() error {
				s.QuantityRest.Reset()
				if err := s.QuantityRest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantityRest\"")
			}
		case "quantityDone":
			if err := func() error {
				s.QuantityDone.Reset()
				if err := s.QuantityDone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantityDone\"")
			}
		case "cancelDateTime":
			if err := func() error {
				s.CancelDateTime.Reset()
				if err := s.CancelDateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelDateTime\"")
			}
		case "cancelReason":
			if err := func() error {
				s.CancelReason.Reset()
				if err := s.CancelReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelReason\"")
			}
		case "tradesInfo":
			if err := func() error {
				s.TradesInfo.Reset()
				if err := s.TradesInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradesInfo\"")
			}
		case "assetUid":
			if err := func() error {
				s.AssetUid.Reset()
				if err := s.AssetUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OperationItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OperationItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OperationItemTrade) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OperationItemTrade) encodeFields(e *jx.Encoder) {
	{
		if s.Num.Set {
			e.FieldStart("num")
			s.Num.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Yield.Set {
			e.FieldStart("yield")
			s.Yield.Encode(e)
		}
	}
	{
		if s.YieldRelative.Set {
			e.FieldStart("yieldRelative")
			s.YieldRelative.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OperationItemTrade = [6]string{
	0: "num",
	1: "date",
	2: "quantity",
	3: "price",
	4: "yield",
	5: "yieldRelative",
}

// Decode decodes V1OperationItemTrade from json.
func (s *V1OperationItemTrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationItemTrade to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "num":
			if err := func() error {
				s.Num.Reset()
				if err := s.Num.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "yield":
			if err := func() error {
				s.Yield.Reset()
				if err := s.Yield.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yield\"")
			}
		case "yieldRelative":
			if err := func() error {
				s.YieldRelative.Reset()
				if err := s.YieldRelative.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yieldRelative\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OperationItemTrade")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OperationItemTrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationItemTrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OperationItemTrades) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OperationItemTrades) encodeFields(e *jx.Encoder) {
	{
		if s.Trades != nil {
			e.FieldStart("trades")
			e.ArrStart()
			for _, elem := range s.Trades {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1OperationItemTrades = [1]string{
	0: "trades",
}

// Decode decodes V1OperationItemTrades from json.
func (s *V1OperationItemTrades) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationItemTrades to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trades":
			if err := func() error {
				s.Trades = make([]V1OperationItemTrade, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1OperationItemTrade
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Trades = append(s.Trades, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trades\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OperationItemTrades")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OperationItemTrades) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationItemTrades) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OperationState as json.
func (s V1OperationState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OperationState from json.
func (s *V1OperationState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OperationState(v) {
	case V1OperationStateOPERATIONSTATEUNSPECIFIED:
		*s = V1OperationStateOPERATIONSTATEUNSPECIFIED
	case V1OperationStateOPERATIONSTATEEXECUTED:
		*s = V1OperationStateOPERATIONSTATEEXECUTED
	case V1OperationStateOPERATIONSTATECANCELED:
		*s = V1OperationStateOPERATIONSTATECANCELED
	case V1OperationStateOPERATIONSTATEPROGRESS:
		*s = V1OperationStateOPERATIONSTATEPROGRESS
	default:
		*s = V1OperationState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OperationState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OperationTrade) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OperationTrade) encodeFields(e *jx.Encoder) {
	{
		if s.TradeId.Set {
			e.FieldStart("tradeId")
			s.TradeId.Encode(e)
		}
	}
	{
		if s.DateTime.Set {
			e.FieldStart("dateTime")
			s.DateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OperationTrade = [4]string{
	0: "tradeId",
	1: "dateTime",
	2: "quantity",
	3: "price",
}

// Decode decodes V1OperationTrade from json.
func (s *V1OperationTrade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationTrade to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tradeId":
			if err := func() error {
				s.TradeId.Reset()
				if err := s.TradeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeId\"")
			}
		case "dateTime":
			if err := func() error {
				s.DateTime.Reset()
				if err := s.DateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateTime\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OperationTrade")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OperationTrade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationTrade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OperationType as json.
func (s V1OperationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OperationType from json.
func (s *V1OperationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OperationType(v) {
	case V1OperationTypeOPERATIONTYPEUNSPECIFIED:
		*s = V1OperationTypeOPERATIONTYPEUNSPECIFIED
	case V1OperationTypeOPERATIONTYPEINPUT:
		*s = V1OperationTypeOPERATIONTYPEINPUT
	case V1OperationTypeOPERATIONTYPEBONDTAX:
		*s = V1OperationTypeOPERATIONTYPEBONDTAX
	case V1OperationTypeOPERATIONTYPEOUTPUTSECURITIES:
		*s = V1OperationTypeOPERATIONTYPEOUTPUTSECURITIES
	case V1OperationTypeOPERATIONTYPEOVERNIGHT:
		*s = V1OperationTypeOPERATIONTYPEOVERNIGHT
	case V1OperationTypeOPERATIONTYPETAX:
		*s = V1OperationTypeOPERATIONTYPETAX
	case V1OperationTypeOPERATIONTYPEBONDREPAYMENTFULL:
		*s = V1OperationTypeOPERATIONTYPEBONDREPAYMENTFULL
	case V1OperationTypeOPERATIONTYPESELLCARD:
		*s = V1OperationTypeOPERATIONTYPESELLCARD
	case V1OperationTypeOPERATIONTYPEDIVIDENDTAX:
		*s = V1OperationTypeOPERATIONTYPEDIVIDENDTAX
	case V1OperationTypeOPERATIONTYPEOUTPUT:
		*s = V1OperationTypeOPERATIONTYPEOUTPUT
	case V1OperationTypeOPERATIONTYPEBONDREPAYMENT:
		*s = V1OperationTypeOPERATIONTYPEBONDREPAYMENT
	case V1OperationTypeOPERATIONTYPETAXCORRECTION:
		*s = V1OperationTypeOPERATIONTYPETAXCORRECTION
	case V1OperationTypeOPERATIONTYPESERVICEFEE:
		*s = V1OperationTypeOPERATIONTYPESERVICEFEE
	case V1OperationTypeOPERATIONTYPEBENEFITTAX:
		*s = V1OperationTypeOPERATIONTYPEBENEFITTAX
	case V1OperationTypeOPERATIONTYPEMARGINFEE:
		*s = V1OperationTypeOPERATIONTYPEMARGINFEE
	case V1OperationTypeOPERATIONTYPEBUY:
		*s = V1OperationTypeOPERATIONTYPEBUY
	case V1OperationTypeOPERATIONTYPEBUYCARD:
		*s = V1OperationTypeOPERATIONTYPEBUYCARD
	case V1OperationTypeOPERATIONTYPEINPUTSECURITIES:
		*s = V1OperationTypeOPERATIONTYPEINPUTSECURITIES
	case V1OperationTypeOPERATIONTYPESELLMARGIN:
		*s = V1OperationTypeOPERATIONTYPESELLMARGIN
	case V1OperationTypeOPERATIONTYPEBROKERFEE:
		*s = V1OperationTypeOPERATIONTYPEBROKERFEE
	case V1OperationTypeOPERATIONTYPEBUYMARGIN:
		*s = V1OperationTypeOPERATIONTYPEBUYMARGIN
	case V1OperationTypeOPERATIONTYPEDIVIDEND:
		*s = V1OperationTypeOPERATIONTYPEDIVIDEND
	case V1OperationTypeOPERATIONTYPESELL:
		*s = V1OperationTypeOPERATIONTYPESELL
	case V1OperationTypeOPERATIONTYPECOUPON:
		*s = V1OperationTypeOPERATIONTYPECOUPON
	case V1OperationTypeOPERATIONTYPESUCCESSFEE:
		*s = V1OperationTypeOPERATIONTYPESUCCESSFEE
	case V1OperationTypeOPERATIONTYPEDIVIDENDTRANSFER:
		*s = V1OperationTypeOPERATIONTYPEDIVIDENDTRANSFER
	case V1OperationTypeOPERATIONTYPEACCRUINGVARMARGIN:
		*s = V1OperationTypeOPERATIONTYPEACCRUINGVARMARGIN
	case V1OperationTypeOPERATIONTYPEWRITINGOFFVARMARGIN:
		*s = V1OperationTypeOPERATIONTYPEWRITINGOFFVARMARGIN
	case V1OperationTypeOPERATIONTYPEDELIVERYBUY:
		*s = V1OperationTypeOPERATIONTYPEDELIVERYBUY
	case V1OperationTypeOPERATIONTYPEDELIVERYSELL:
		*s = V1OperationTypeOPERATIONTYPEDELIVERYSELL
	case V1OperationTypeOPERATIONTYPETRACKMFEE:
		*s = V1OperationTypeOPERATIONTYPETRACKMFEE
	case V1OperationTypeOPERATIONTYPETRACKPFEE:
		*s = V1OperationTypeOPERATIONTYPETRACKPFEE
	case V1OperationTypeOPERATIONTYPETAXPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPETAXPROGRESSIVE
	case V1OperationTypeOPERATIONTYPEBONDTAXPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPEBONDTAXPROGRESSIVE
	case V1OperationTypeOPERATIONTYPEDIVIDENDTAXPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPEDIVIDENDTAXPROGRESSIVE
	case V1OperationTypeOPERATIONTYPEBENEFITTAXPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPEBENEFITTAXPROGRESSIVE
	case V1OperationTypeOPERATIONTYPETAXCORRECTIONPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPETAXCORRECTIONPROGRESSIVE
	case V1OperationTypeOPERATIONTYPETAXREPOPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPETAXREPOPROGRESSIVE
	case V1OperationTypeOPERATIONTYPETAXREPO:
		*s = V1OperationTypeOPERATIONTYPETAXREPO
	case V1OperationTypeOPERATIONTYPETAXREPOHOLD:
		*s = V1OperationTypeOPERATIONTYPETAXREPOHOLD
	case V1OperationTypeOPERATIONTYPETAXREPOREFUND:
		*s = V1OperationTypeOPERATIONTYPETAXREPOREFUND
	case V1OperationTypeOPERATIONTYPETAXREPOHOLDPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPETAXREPOHOLDPROGRESSIVE
	case V1OperationTypeOPERATIONTYPETAXREPOREFUNDPROGRESSIVE:
		*s = V1OperationTypeOPERATIONTYPETAXREPOREFUNDPROGRESSIVE
	case V1OperationTypeOPERATIONTYPEDIVEXT:
		*s = V1OperationTypeOPERATIONTYPEDIVEXT
	case V1OperationTypeOPERATIONTYPETAXCORRECTIONCOUPON:
		*s = V1OperationTypeOPERATIONTYPETAXCORRECTIONCOUPON
	case V1OperationTypeOPERATIONTYPECASHFEE:
		*s = V1OperationTypeOPERATIONTYPECASHFEE
	case V1OperationTypeOPERATIONTYPEOUTFEE:
		*s = V1OperationTypeOPERATIONTYPEOUTFEE
	case V1OperationTypeOPERATIONTYPEOUTSTAMPDUTY:
		*s = V1OperationTypeOPERATIONTYPEOUTSTAMPDUTY
	case V1OperationTypeOPERATIONTYPEOUTPUTSWIFT:
		*s = V1OperationTypeOPERATIONTYPEOUTPUTSWIFT
	case V1OperationTypeOPERATIONTYPEINPUTSWIFT:
		*s = V1OperationTypeOPERATIONTYPEINPUTSWIFT
	case V1OperationTypeOPERATIONTYPEOUTPUTACQUIRING:
		*s = V1OperationTypeOPERATIONTYPEOUTPUTACQUIRING
	case V1OperationTypeOPERATIONTYPEINPUTACQUIRING:
		*s = V1OperationTypeOPERATIONTYPEINPUTACQUIRING
	case V1OperationTypeOPERATIONTYPEOUTPUTPENALTY:
		*s = V1OperationTypeOPERATIONTYPEOUTPUTPENALTY
	case V1OperationTypeOPERATIONTYPEADVICEFEE:
		*s = V1OperationTypeOPERATIONTYPEADVICEFEE
	case V1OperationTypeOPERATIONTYPETRANSIISBS:
		*s = V1OperationTypeOPERATIONTYPETRANSIISBS
	case V1OperationTypeOPERATIONTYPETRANSBSBS:
		*s = V1OperationTypeOPERATIONTYPETRANSBSBS
	case V1OperationTypeOPERATIONTYPEOUTMULTI:
		*s = V1OperationTypeOPERATIONTYPEOUTMULTI
	case V1OperationTypeOPERATIONTYPEINPMULTI:
		*s = V1OperationTypeOPERATIONTYPEINPMULTI
	case V1OperationTypeOPERATIONTYPEOVERPLACEMENT:
		*s = V1OperationTypeOPERATIONTYPEOVERPLACEMENT
	case V1OperationTypeOPERATIONTYPEOVERCOM:
		*s = V1OperationTypeOPERATIONTYPEOVERCOM
	case V1OperationTypeOPERATIONTYPEOVERINCOME:
		*s = V1OperationTypeOPERATIONTYPEOVERINCOME
	case V1OperationTypeOPERATIONTYPEOPTIONEXPIRATION:
		*s = V1OperationTypeOPERATIONTYPEOPTIONEXPIRATION
	default:
		*s = V1OperationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OperationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OperationsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OperationsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OperationsRequest = [5]string{
	0: "accountId",
	1: "from",
	2: "to",
	3: "state",
	4: "figi",
}

// Decode decodes V1OperationsRequest from json.
func (s *V1OperationsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationsRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OperationsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OperationsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OperationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OperationsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Operations != nil {
			e.FieldStart("operations")
			e.ArrStart()
			for _, elem := range s.Operations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1OperationsResponse = [1]string{
	0: "operations",
}

// Decode decodes V1OperationsResponse from json.
func (s *V1OperationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OperationsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operations":
			if err := func() error {
				s.Operations = make([]V1Operation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Operation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OperationsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OperationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OperationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Option) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Option) encodeFields(e *jx.Encoder) {
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.BasicAssetPositionUid.Set {
			e.FieldStart("basicAssetPositionUid")
			s.BasicAssetPositionUid.Encode(e)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.RealExchange.Set {
			e.FieldStart("realExchange")
			s.RealExchange.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.PaymentType.Set {
			e.FieldStart("paymentType")
			s.PaymentType.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.SettlementType.Set {
			e.FieldStart("settlementType")
			s.SettlementType.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.SettlementCurrency.Set {
			e.FieldStart("settlementCurrency")
			s.SettlementCurrency.Encode(e)
		}
	}
	{
		if s.AssetType.Set {
			e.FieldStart("assetType")
			s.AssetType.Encode(e)
		}
	}
	{
		if s.BasicAsset.Set {
			e.FieldStart("basicAsset")
			s.BasicAsset.Encode(e)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
	{
		if s.Sector.Set {
			e.FieldStart("sector")
			s.Sector.Encode(e)
		}
	}
	{
		if s.Lot.Set {
			e.FieldStart("lot")
			s.Lot.Encode(e)
		}
	}
	{
		if s.BasicAssetSize.Set {
			e.FieldStart("basicAssetSize")
			s.BasicAssetSize.Encode(e)
		}
	}
	{
		if s.Klong.Set {
			e.FieldStart("klong")
			s.Klong.Encode(e)
		}
	}
	{
		if s.Kshort.Set {
			e.FieldStart("kshort")
			s.Kshort.Encode(e)
		}
	}
	{
		if s.Dlong.Set {
			e.FieldStart("dlong")
			s.Dlong.Encode(e)
		}
	}
	{
		if s.Dshort.Set {
			e.FieldStart("dshort")
			s.Dshort.Encode(e)
		}
	}
	{
		if s.DlongMin.Set {
			e.FieldStart("dlongMin")
			s.DlongMin.Encode(e)
		}
	}
	{
		if s.DshortMin.Set {
			e.FieldStart("dshortMin")
			s.DshortMin.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.StrikePrice.Set {
			e.FieldStart("strikePrice")
			s.StrikePrice.Encode(e)
		}
	}
	{
		if s.ExpirationDate.Set {
			e.FieldStart("expirationDate")
			s.ExpirationDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FirstTradeDate.Set {
			e.FieldStart("firstTradeDate")
			s.FirstTradeDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastTradeDate.Set {
			e.FieldStart("lastTradeDate")
			s.LastTradeDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ShortEnabledFlag.Set {
			e.FieldStart("shortEnabledFlag")
			s.ShortEnabledFlag.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.BuyAvailableFlag.Set {
			e.FieldStart("buyAvailableFlag")
			s.BuyAvailableFlag.Encode(e)
		}
	}
	{
		if s.SellAvailableFlag.Set {
			e.FieldStart("sellAvailableFlag")
			s.SellAvailableFlag.Encode(e)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Option = [44]string{
	0:  "uid",
	1:  "positionUid",
	2:  "ticker",
	3:  "classCode",
	4:  "basicAssetPositionUid",
	5:  "tradingStatus",
	6:  "realExchange",
	7:  "direction",
	8:  "paymentType",
	9:  "style",
	10: "settlementType",
	11: "name",
	12: "currency",
	13: "settlementCurrency",
	14: "assetType",
	15: "basicAsset",
	16: "exchange",
	17: "countryOfRisk",
	18: "countryOfRiskName",
	19: "sector",
	20: "lot",
	21: "basicAssetSize",
	22: "klong",
	23: "kshort",
	24: "dlong",
	25: "dshort",
	26: "dlongMin",
	27: "dshortMin",
	28: "minPriceIncrement",
	29: "strikePrice",
	30: "expirationDate",
	31: "firstTradeDate",
	32: "lastTradeDate",
	33: "first1minCandleDate",
	34: "first1dayCandleDate",
	35: "shortEnabledFlag",
	36: "forIisFlag",
	37: "otcFlag",
	38: "buyAvailableFlag",
	39: "sellAvailableFlag",
	40: "forQualInvestorFlag",
	41: "weekendFlag",
	42: "blockedTcaFlag",
	43: "apiTradeAvailableFlag",
}

// Decode decodes V1Option from json.
func (s *V1Option) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Option to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "basicAssetPositionUid":
			if err := func() error {
				s.BasicAssetPositionUid.Reset()
				if err := s.BasicAssetPositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAssetPositionUid\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "realExchange":
			if err := func() error {
				s.RealExchange.Reset()
				if err := s.RealExchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realExchange\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "paymentType":
			if err := func() error {
				s.PaymentType.Reset()
				if err := s.PaymentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paymentType\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "settlementType":
			if err := func() error {
				s.SettlementType.Reset()
				if err := s.SettlementType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settlementType\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "settlementCurrency":
			if err := func() error {
				s.SettlementCurrency.Reset()
				if err := s.SettlementCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settlementCurrency\"")
			}
		case "assetType":
			if err := func() error {
				s.AssetType.Reset()
				if err := s.AssetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetType\"")
			}
		case "basicAsset":
			if err := func() error {
				s.BasicAsset.Reset()
				if err := s.BasicAsset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAsset\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		case "sector":
			if err := func() error {
				s.Sector.Reset()
				if err := s.Sector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sector\"")
			}
		case "lot":
			if err := func() error {
				s.Lot.Reset()
				if err := s.Lot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "basicAssetSize":
			if err := func() error {
				s.BasicAssetSize.Reset()
				if err := s.BasicAssetSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAssetSize\"")
			}
		case "klong":
			if err := func() error {
				s.Klong.Reset()
				if err := s.Klong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"klong\"")
			}
		case "kshort":
			if err := func() error {
				s.Kshort.Reset()
				if err := s.Kshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kshort\"")
			}
		case "dlong":
			if err := func() error {
				s.Dlong.Reset()
				if err := s.Dlong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlong\"")
			}
		case "dshort":
			if err := func() error {
				s.Dshort.Reset()
				if err := s.Dshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshort\"")
			}
		case "dlongMin":
			if err := func() error {
				s.DlongMin.Reset()
				if err := s.DlongMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlongMin\"")
			}
		case "dshortMin":
			if err := func() error {
				s.DshortMin.Reset()
				if err := s.DshortMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshortMin\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "strikePrice":
			if err := func() error {
				s.StrikePrice.Reset()
				if err := s.StrikePrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strikePrice\"")
			}
		case "expirationDate":
			if err := func() error {
				s.ExpirationDate.Reset()
				if err := s.ExpirationDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationDate\"")
			}
		case "firstTradeDate":
			if err := func() error {
				s.FirstTradeDate.Reset()
				if err := s.FirstTradeDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTradeDate\"")
			}
		case "lastTradeDate":
			if err := func() error {
				s.LastTradeDate.Reset()
				if err := s.LastTradeDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTradeDate\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		case "shortEnabledFlag":
			if err := func() error {
				s.ShortEnabledFlag.Reset()
				if err := s.ShortEnabledFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortEnabledFlag\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "buyAvailableFlag":
			if err := func() error {
				s.BuyAvailableFlag.Reset()
				if err := s.BuyAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyAvailableFlag\"")
			}
		case "sellAvailableFlag":
			if err := func() error {
				s.SellAvailableFlag.Reset()
				if err := s.SellAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellAvailableFlag\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Option")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Option) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Option) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionDirection as json.
func (s V1OptionDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OptionDirection from json.
func (s *V1OptionDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OptionDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OptionDirection(v) {
	case V1OptionDirectionOPTIONDIRECTIONUNSPECIFIED:
		*s = V1OptionDirectionOPTIONDIRECTIONUNSPECIFIED
	case V1OptionDirectionOPTIONDIRECTIONPUT:
		*s = V1OptionDirectionOPTIONDIRECTIONPUT
	case V1OptionDirectionOPTIONDIRECTIONCALL:
		*s = V1OptionDirectionOPTIONDIRECTIONCALL
	default:
		*s = V1OptionDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OptionDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OptionDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionPaymentType as json.
func (s V1OptionPaymentType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OptionPaymentType from json.
func (s *V1OptionPaymentType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OptionPaymentType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OptionPaymentType(v) {
	case V1OptionPaymentTypeOPTIONPAYMENTTYPEUNSPECIFIED:
		*s = V1OptionPaymentTypeOPTIONPAYMENTTYPEUNSPECIFIED
	case V1OptionPaymentTypeOPTIONPAYMENTTYPEPREMIUM:
		*s = V1OptionPaymentTypeOPTIONPAYMENTTYPEPREMIUM
	case V1OptionPaymentTypeOPTIONPAYMENTTYPEMARGINAL:
		*s = V1OptionPaymentTypeOPTIONPAYMENTTYPEMARGINAL
	default:
		*s = V1OptionPaymentType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OptionPaymentType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OptionPaymentType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OptionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instrument.Set {
			e.FieldStart("instrument")
			s.Instrument.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OptionResponse = [1]string{
	0: "instrument",
}

// Decode decodes V1OptionResponse from json.
func (s *V1OptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OptionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrument":
			if err := func() error {
				s.Instrument.Reset()
				if err := s.Instrument.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrument\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OptionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionSettlementType as json.
func (s V1OptionSettlementType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OptionSettlementType from json.
func (s *V1OptionSettlementType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OptionSettlementType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OptionSettlementType(v) {
	case V1OptionSettlementTypeOPTIONEXECUTIONTYPEUNSPECIFIED:
		*s = V1OptionSettlementTypeOPTIONEXECUTIONTYPEUNSPECIFIED
	case V1OptionSettlementTypeOPTIONEXECUTIONTYPEPHYSICALDELIVERY:
		*s = V1OptionSettlementTypeOPTIONEXECUTIONTYPEPHYSICALDELIVERY
	case V1OptionSettlementTypeOPTIONEXECUTIONTYPECASHSETTLEMENT:
		*s = V1OptionSettlementTypeOPTIONEXECUTIONTYPECASHSETTLEMENT
	default:
		*s = V1OptionSettlementType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OptionSettlementType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OptionSettlementType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OptionStyle as json.
func (s V1OptionStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OptionStyle from json.
func (s *V1OptionStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OptionStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OptionStyle(v) {
	case V1OptionStyleOPTIONSTYLEUNSPECIFIED:
		*s = V1OptionStyleOPTIONSTYLEUNSPECIFIED
	case V1OptionStyleOPTIONSTYLEAMERICAN:
		*s = V1OptionStyleOPTIONSTYLEAMERICAN
	case V1OptionStyleOPTIONSTYLEEUROPEAN:
		*s = V1OptionStyleOPTIONSTYLEEUROPEAN
	default:
		*s = V1OptionStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OptionStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OptionStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OptionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OptionsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1OptionsResponse = [1]string{
	0: "instruments",
}

// Decode decodes V1OptionsResponse from json.
func (s *V1OptionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OptionsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1Option, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Option
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OptionsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OptionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OptionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Order) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Order) encodeFields(e *jx.Encoder) {
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Order = [2]string{
	0: "price",
	1: "quantity",
}

// Decode decodes V1Order from json.
func (s *V1Order) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Order to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Order")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Order) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Order) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OrderDirection as json.
func (s V1OrderDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OrderDirection from json.
func (s *V1OrderDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrderDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OrderDirection(v) {
	case V1OrderDirectionORDERDIRECTIONUNSPECIFIED:
		*s = V1OrderDirectionORDERDIRECTIONUNSPECIFIED
	case V1OrderDirectionORDERDIRECTIONBUY:
		*s = V1OrderDirectionORDERDIRECTIONBUY
	case V1OrderDirectionORDERDIRECTIONSELL:
		*s = V1OrderDirectionORDERDIRECTIONSELL
	default:
		*s = V1OrderDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OrderDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrderDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OrderExecutionReportStatus as json.
func (s V1OrderExecutionReportStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OrderExecutionReportStatus from json.
func (s *V1OrderExecutionReportStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrderExecutionReportStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OrderExecutionReportStatus(v) {
	case V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSUNSPECIFIED:
		*s = V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSUNSPECIFIED
	case V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSFILL:
		*s = V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSFILL
	case V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSREJECTED:
		*s = V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSREJECTED
	case V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSCANCELLED:
		*s = V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSCANCELLED
	case V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSNEW:
		*s = V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSNEW
	case V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSPARTIALLYFILL:
		*s = V1OrderExecutionReportStatusEXECUTIONREPORTSTATUSPARTIALLYFILL
	default:
		*s = V1OrderExecutionReportStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OrderExecutionReportStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrderExecutionReportStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OrderStage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OrderStage) encodeFields(e *jx.Encoder) {
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.TradeId.Set {
			e.FieldStart("tradeId")
			s.TradeId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OrderStage = [3]string{
	0: "price",
	1: "quantity",
	2: "tradeId",
}

// Decode decodes V1OrderStage from json.
func (s *V1OrderStage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrderStage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "tradeId":
			if err := func() error {
				s.TradeId.Reset()
				if err := s.TradeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradeId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OrderStage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OrderStage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrderStage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1OrderState) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1OrderState) encodeFields(e *jx.Encoder) {
	{
		if s.OrderId.Set {
			e.FieldStart("orderId")
			s.OrderId.Encode(e)
		}
	}
	{
		if s.ExecutionReportStatus.Set {
			e.FieldStart("executionReportStatus")
			s.ExecutionReportStatus.Encode(e)
		}
	}
	{
		if s.LotsRequested.Set {
			e.FieldStart("lotsRequested")
			s.LotsRequested.Encode(e)
		}
	}
	{
		if s.LotsExecuted.Set {
			e.FieldStart("lotsExecuted")
			s.LotsExecuted.Encode(e)
		}
	}
	{
		if s.InitialOrderPrice.Set {
			e.FieldStart("initialOrderPrice")
			s.InitialOrderPrice.Encode(e)
		}
	}
	{
		if s.ExecutedOrderPrice.Set {
			e.FieldStart("executedOrderPrice")
			s.ExecutedOrderPrice.Encode(e)
		}
	}
	{
		if s.TotalOrderAmount.Set {
			e.FieldStart("totalOrderAmount")
			s.TotalOrderAmount.Encode(e)
		}
	}
	{
		if s.AveragePositionPrice.Set {
			e.FieldStart("averagePositionPrice")
			s.AveragePositionPrice.Encode(e)
		}
	}
	{
		if s.InitialCommission.Set {
			e.FieldStart("initialCommission")
			s.InitialCommission.Encode(e)
		}
	}
	{
		if s.ExecutedCommission.Set {
			e.FieldStart("executedCommission")
			s.ExecutedCommission.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.InitialSecurityPrice.Set {
			e.FieldStart("initialSecurityPrice")
			s.InitialSecurityPrice.Encode(e)
		}
	}
	{
		if s.Stages != nil {
			e.FieldStart("stages")
			e.ArrStart()
			for _, elem := range s.Stages {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ServiceCommission.Set {
			e.FieldStart("serviceCommission")
			s.ServiceCommission.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.OrderType.Set {
			e.FieldStart("orderType")
			s.OrderType.Encode(e)
		}
	}
	{
		if s.OrderDate.Set {
			e.FieldStart("orderDate")
			s.OrderDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1OrderState = [19]string{
	0:  "orderId",
	1:  "executionReportStatus",
	2:  "lotsRequested",
	3:  "lotsExecuted",
	4:  "initialOrderPrice",
	5:  "executedOrderPrice",
	6:  "totalOrderAmount",
	7:  "averagePositionPrice",
	8:  "initialCommission",
	9:  "executedCommission",
	10: "figi",
	11: "direction",
	12: "initialSecurityPrice",
	13: "stages",
	14: "serviceCommission",
	15: "currency",
	16: "orderType",
	17: "orderDate",
	18: "instrumentUid",
}

// Decode decodes V1OrderState from json.
func (s *V1OrderState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrderState to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			if err := func() error {
				s.OrderId.Reset()
				if err := s.OrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "executionReportStatus":
			if err := func() error {
				s.ExecutionReportStatus.Reset()
				if err := s.ExecutionReportStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionReportStatus\"")
			}
		case "lotsRequested":
			if err := func() error {
				s.LotsRequested.Reset()
				if err := s.LotsRequested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lotsRequested\"")
			}
		case "lotsExecuted":
			if err := func() error {
				s.LotsExecuted.Reset()
				if err := s.LotsExecuted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lotsExecuted\"")
			}
		case "initialOrderPrice":
			if err := func() error {
				s.InitialOrderPrice.Reset()
				if err := s.InitialOrderPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialOrderPrice\"")
			}
		case "executedOrderPrice":
			if err := func() error {
				s.ExecutedOrderPrice.Reset()
				if err := s.ExecutedOrderPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executedOrderPrice\"")
			}
		case "totalOrderAmount":
			if err := func() error {
				s.TotalOrderAmount.Reset()
				if err := s.TotalOrderAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalOrderAmount\"")
			}
		case "averagePositionPrice":
			if err := func() error {
				s.AveragePositionPrice.Reset()
				if err := s.AveragePositionPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPrice\"")
			}
		case "initialCommission":
			if err := func() error {
				s.InitialCommission.Reset()
				if err := s.InitialCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialCommission\"")
			}
		case "executedCommission":
			if err := func() error {
				s.ExecutedCommission.Reset()
				if err := s.ExecutedCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executedCommission\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "initialSecurityPrice":
			if err := func() error {
				s.InitialSecurityPrice.Reset()
				if err := s.InitialSecurityPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialSecurityPrice\"")
			}
		case "stages":
			if err := func() error {
				s.Stages = make([]V1OrderStage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1OrderStage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Stages = append(s.Stages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stages\"")
			}
		case "serviceCommission":
			if err := func() error {
				s.ServiceCommission.Reset()
				if err := s.ServiceCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceCommission\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "orderType":
			if err := func() error {
				s.OrderType.Reset()
				if err := s.OrderType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderType\"")
			}
		case "orderDate":
			if err := func() error {
				s.OrderDate.Reset()
				if err := s.OrderDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderDate\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1OrderState")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1OrderState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrderState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1OrderType as json.
func (s V1OrderType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1OrderType from json.
func (s *V1OrderType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1OrderType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1OrderType(v) {
	case V1OrderTypeORDERTYPEUNSPECIFIED:
		*s = V1OrderTypeORDERTYPEUNSPECIFIED
	case V1OrderTypeORDERTYPELIMIT:
		*s = V1OrderTypeORDERTYPELIMIT
	case V1OrderTypeORDERTYPEMARKET:
		*s = V1OrderTypeORDERTYPEMARKET
	default:
		*s = V1OrderType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1OrderType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1OrderType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PortfolioPosition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PortfolioPosition) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.AveragePositionPrice.Set {
			e.FieldStart("averagePositionPrice")
			s.AveragePositionPrice.Encode(e)
		}
	}
	{
		if s.ExpectedYield.Set {
			e.FieldStart("expectedYield")
			s.ExpectedYield.Encode(e)
		}
	}
	{
		if s.CurrentNkd.Set {
			e.FieldStart("currentNkd")
			s.CurrentNkd.Encode(e)
		}
	}
	{
		if s.AveragePositionPricePt.Set {
			e.FieldStart("averagePositionPricePt")
			s.AveragePositionPricePt.Encode(e)
		}
	}
	{
		if s.CurrentPrice.Set {
			e.FieldStart("currentPrice")
			s.CurrentPrice.Encode(e)
		}
	}
	{
		if s.AveragePositionPriceFifo.Set {
			e.FieldStart("averagePositionPriceFifo")
			s.AveragePositionPriceFifo.Encode(e)
		}
	}
	{
		if s.QuantityLots.Set {
			e.FieldStart("quantityLots")
			s.QuantityLots.Encode(e)
		}
	}
	{
		if s.Blocked.Set {
			e.FieldStart("blocked")
			s.Blocked.Encode(e)
		}
	}
	{
		if s.BlockedLots.Set {
			e.FieldStart("blockedLots")
			s.BlockedLots.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
	{
		if s.VarMargin.Set {
			e.FieldStart("varMargin")
			s.VarMargin.Encode(e)
		}
	}
	{
		if s.ExpectedYieldFifo.Set {
			e.FieldStart("expectedYieldFifo")
			s.ExpectedYieldFifo.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PortfolioPosition = [16]string{
	0:  "figi",
	1:  "instrumentType",
	2:  "quantity",
	3:  "averagePositionPrice",
	4:  "expectedYield",
	5:  "currentNkd",
	6:  "averagePositionPricePt",
	7:  "currentPrice",
	8:  "averagePositionPriceFifo",
	9:  "quantityLots",
	10: "blocked",
	11: "blockedLots",
	12: "positionUid",
	13: "instrumentUid",
	14: "varMargin",
	15: "expectedYieldFifo",
}

// Decode decodes V1PortfolioPosition from json.
func (s *V1PortfolioPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PortfolioPosition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "averagePositionPrice":
			if err := func() error {
				s.AveragePositionPrice.Reset()
				if err := s.AveragePositionPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPrice\"")
			}
		case "expectedYield":
			if err := func() error {
				s.ExpectedYield.Reset()
				if err := s.ExpectedYield.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedYield\"")
			}
		case "currentNkd":
			if err := func() error {
				s.CurrentNkd.Reset()
				if err := s.CurrentNkd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentNkd\"")
			}
		case "averagePositionPricePt":
			if err := func() error {
				s.AveragePositionPricePt.Reset()
				if err := s.AveragePositionPricePt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPricePt\"")
			}
		case "currentPrice":
			if err := func() error {
				s.CurrentPrice.Reset()
				if err := s.CurrentPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentPrice\"")
			}
		case "averagePositionPriceFifo":
			if err := func() error {
				s.AveragePositionPriceFifo.Reset()
				if err := s.AveragePositionPriceFifo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPriceFifo\"")
			}
		case "quantityLots":
			if err := func() error {
				s.QuantityLots.Reset()
				if err := s.QuantityLots.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantityLots\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked.Reset()
				if err := s.Blocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "blockedLots":
			if err := func() error {
				s.BlockedLots.Reset()
				if err := s.BlockedLots.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedLots\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		case "varMargin":
			if err := func() error {
				s.VarMargin.Reset()
				if err := s.VarMargin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"varMargin\"")
			}
		case "expectedYieldFifo":
			if err := func() error {
				s.ExpectedYieldFifo.Reset()
				if err := s.ExpectedYieldFifo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedYieldFifo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PortfolioPosition")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PortfolioPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PortfolioPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PortfolioRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PortfolioRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PortfolioRequest = [2]string{
	0: "accountId",
	1: "currency",
}

// Decode decodes V1PortfolioRequest from json.
func (s *V1PortfolioRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PortfolioRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PortfolioRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PortfolioRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PortfolioRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PortfolioResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PortfolioResponse) encodeFields(e *jx.Encoder) {
	{
		if s.TotalAmountShares.Set {
			e.FieldStart("totalAmountShares")
			s.TotalAmountShares.Encode(e)
		}
	}
	{
		if s.TotalAmountBonds.Set {
			e.FieldStart("totalAmountBonds")
			s.TotalAmountBonds.Encode(e)
		}
	}
	{
		if s.TotalAmountEtf.Set {
			e.FieldStart("totalAmountEtf")
			s.TotalAmountEtf.Encode(e)
		}
	}
	{
		if s.TotalAmountCurrencies.Set {
			e.FieldStart("totalAmountCurrencies")
			s.TotalAmountCurrencies.Encode(e)
		}
	}
	{
		if s.TotalAmountFutures.Set {
			e.FieldStart("totalAmountFutures")
			s.TotalAmountFutures.Encode(e)
		}
	}
	{
		if s.ExpectedYield.Set {
			e.FieldStart("expectedYield")
			s.ExpectedYield.Encode(e)
		}
	}
	{
		if s.Positions != nil {
			e.FieldStart("positions")
			e.ArrStart()
			for _, elem := range s.Positions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.TotalAmountOptions.Set {
			e.FieldStart("totalAmountOptions")
			s.TotalAmountOptions.Encode(e)
		}
	}
	{
		if s.TotalAmountSp.Set {
			e.FieldStart("totalAmountSp")
			s.TotalAmountSp.Encode(e)
		}
	}
	{
		if s.TotalAmountPortfolio.Set {
			e.FieldStart("totalAmountPortfolio")
			s.TotalAmountPortfolio.Encode(e)
		}
	}
	{
		if s.VirtualPositions != nil {
			e.FieldStart("virtualPositions")
			e.ArrStart()
			for _, elem := range s.VirtualPositions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1PortfolioResponse = [12]string{
	0:  "totalAmountShares",
	1:  "totalAmountBonds",
	2:  "totalAmountEtf",
	3:  "totalAmountCurrencies",
	4:  "totalAmountFutures",
	5:  "expectedYield",
	6:  "positions",
	7:  "accountId",
	8:  "totalAmountOptions",
	9:  "totalAmountSp",
	10: "totalAmountPortfolio",
	11: "virtualPositions",
}

// Decode decodes V1PortfolioResponse from json.
func (s *V1PortfolioResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PortfolioResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmountShares":
			if err := func() error {
				s.TotalAmountShares.Reset()
				if err := s.TotalAmountShares.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountShares\"")
			}
		case "totalAmountBonds":
			if err := func() error {
				s.TotalAmountBonds.Reset()
				if err := s.TotalAmountBonds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountBonds\"")
			}
		case "totalAmountEtf":
			if err := func() error {
				s.TotalAmountEtf.Reset()
				if err := s.TotalAmountEtf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountEtf\"")
			}
		case "totalAmountCurrencies":
			if err := func() error {
				s.TotalAmountCurrencies.Reset()
				if err := s.TotalAmountCurrencies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountCurrencies\"")
			}
		case "totalAmountFutures":
			if err := func() error {
				s.TotalAmountFutures.Reset()
				if err := s.TotalAmountFutures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountFutures\"")
			}
		case "expectedYield":
			if err := func() error {
				s.ExpectedYield.Reset()
				if err := s.ExpectedYield.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedYield\"")
			}
		case "positions":
			if err := func() error {
				s.Positions = make([]V1PortfolioPosition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1PortfolioPosition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Positions = append(s.Positions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positions\"")
			}
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "totalAmountOptions":
			if err := func() error {
				s.TotalAmountOptions.Reset()
				if err := s.TotalAmountOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountOptions\"")
			}
		case "totalAmountSp":
			if err := func() error {
				s.TotalAmountSp.Reset()
				if err := s.TotalAmountSp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountSp\"")
			}
		case "totalAmountPortfolio":
			if err := func() error {
				s.TotalAmountPortfolio.Reset()
				if err := s.TotalAmountPortfolio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmountPortfolio\"")
			}
		case "virtualPositions":
			if err := func() error {
				s.VirtualPositions = make([]V1VirtualPortfolioPosition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1VirtualPortfolioPosition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VirtualPositions = append(s.VirtualPositions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"virtualPositions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PortfolioResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PortfolioResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PortfolioResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PositionsFutures) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PositionsFutures) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Blocked.Set {
			e.FieldStart("blocked")
			s.Blocked.Encode(e)
		}
	}
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PositionsFutures = [5]string{
	0: "figi",
	1: "blocked",
	2: "balance",
	3: "positionUid",
	4: "instrumentUid",
}

// Decode decodes V1PositionsFutures from json.
func (s *V1PositionsFutures) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PositionsFutures to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked.Reset()
				if err := s.Blocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PositionsFutures")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PositionsFutures) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PositionsFutures) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PositionsOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PositionsOptions) encodeFields(e *jx.Encoder) {
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
	{
		if s.Blocked.Set {
			e.FieldStart("blocked")
			s.Blocked.Encode(e)
		}
	}
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PositionsOptions = [4]string{
	0: "positionUid",
	1: "instrumentUid",
	2: "blocked",
	3: "balance",
}

// Decode decodes V1PositionsOptions from json.
func (s *V1PositionsOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PositionsOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked.Reset()
				if err := s.Blocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PositionsOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PositionsOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PositionsOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PositionsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PositionsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PositionsRequest = [1]string{
	0: "accountId",
}

// Decode decodes V1PositionsRequest from json.
func (s *V1PositionsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PositionsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PositionsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PositionsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PositionsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PositionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PositionsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Money != nil {
			e.FieldStart("money")
			e.ArrStart()
			for _, elem := range s.Money {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Blocked != nil {
			e.FieldStart("blocked")
			e.ArrStart()
			for _, elem := range s.Blocked {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Securities != nil {
			e.FieldStart("securities")
			e.ArrStart()
			for _, elem := range s.Securities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LimitsLoadingInProgress.Set {
			e.FieldStart("limitsLoadingInProgress")
			s.LimitsLoadingInProgress.Encode(e)
		}
	}
	{
		if s.Futures != nil {
			e.FieldStart("futures")
			e.ArrStart()
			for _, elem := range s.Futures {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Options != nil {
			e.FieldStart("options")
			e.ArrStart()
			for _, elem := range s.Options {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1PositionsResponse = [6]string{
	0: "money",
	1: "blocked",
	2: "securities",
	3: "limitsLoadingInProgress",
	4: "futures",
	5: "options",
}

// Decode decodes V1PositionsResponse from json.
func (s *V1PositionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PositionsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "money":
			if err := func() error {
				s.Money = make([]V1MoneyValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1MoneyValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Money = append(s.Money, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"money\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked = make([]V1MoneyValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1MoneyValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Blocked = append(s.Blocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "securities":
			if err := func() error {
				s.Securities = make([]V1PositionsSecurities, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1PositionsSecurities
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Securities = append(s.Securities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securities\"")
			}
		case "limitsLoadingInProgress":
			if err := func() error {
				s.LimitsLoadingInProgress.Reset()
				if err := s.LimitsLoadingInProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitsLoadingInProgress\"")
			}
		case "futures":
			if err := func() error {
				s.Futures = make([]V1PositionsFutures, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1PositionsFutures
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Futures = append(s.Futures, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"futures\"")
			}
		case "options":
			if err := func() error {
				s.Options = make([]V1PositionsOptions, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1PositionsOptions
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Options = append(s.Options, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PositionsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PositionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PositionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PositionsSecurities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PositionsSecurities) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Blocked.Set {
			e.FieldStart("blocked")
			s.Blocked.Encode(e)
		}
	}
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
	{
		if s.ExchangeBlocked.Set {
			e.FieldStart("exchangeBlocked")
			s.ExchangeBlocked.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PositionsSecurities = [7]string{
	0: "figi",
	1: "blocked",
	2: "balance",
	3: "positionUid",
	4: "instrumentUid",
	5: "exchangeBlocked",
	6: "instrumentType",
}

// Decode decodes V1PositionsSecurities from json.
func (s *V1PositionsSecurities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PositionsSecurities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked.Reset()
				if err := s.Blocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		case "exchangeBlocked":
			if err := func() error {
				s.ExchangeBlocked.Reset()
				if err := s.ExchangeBlocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchangeBlocked\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PositionsSecurities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PositionsSecurities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PositionsSecurities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PostOrderRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PostOrderRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.OrderType.Set {
			e.FieldStart("orderType")
			s.OrderType.Encode(e)
		}
	}
	{
		if s.OrderId.Set {
			e.FieldStart("orderId")
			s.OrderId.Encode(e)
		}
	}
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PostOrderRequest = [8]string{
	0: "figi",
	1: "quantity",
	2: "price",
	3: "direction",
	4: "accountId",
	5: "orderType",
	6: "orderId",
	7: "instrumentId",
}

// Decode decodes V1PostOrderRequest from json.
func (s *V1PostOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PostOrderRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "orderType":
			if err := func() error {
				s.OrderType.Reset()
				if err := s.OrderType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderType\"")
			}
		case "orderId":
			if err := func() error {
				s.OrderId.Reset()
				if err := s.OrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PostOrderRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PostOrderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PostOrderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PostOrderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PostOrderResponse) encodeFields(e *jx.Encoder) {
	{
		if s.OrderId.Set {
			e.FieldStart("orderId")
			s.OrderId.Encode(e)
		}
	}
	{
		if s.ExecutionReportStatus.Set {
			e.FieldStart("executionReportStatus")
			s.ExecutionReportStatus.Encode(e)
		}
	}
	{
		if s.LotsRequested.Set {
			e.FieldStart("lotsRequested")
			s.LotsRequested.Encode(e)
		}
	}
	{
		if s.LotsExecuted.Set {
			e.FieldStart("lotsExecuted")
			s.LotsExecuted.Encode(e)
		}
	}
	{
		if s.InitialOrderPrice.Set {
			e.FieldStart("initialOrderPrice")
			s.InitialOrderPrice.Encode(e)
		}
	}
	{
		if s.ExecutedOrderPrice.Set {
			e.FieldStart("executedOrderPrice")
			s.ExecutedOrderPrice.Encode(e)
		}
	}
	{
		if s.TotalOrderAmount.Set {
			e.FieldStart("totalOrderAmount")
			s.TotalOrderAmount.Encode(e)
		}
	}
	{
		if s.InitialCommission.Set {
			e.FieldStart("initialCommission")
			s.InitialCommission.Encode(e)
		}
	}
	{
		if s.ExecutedCommission.Set {
			e.FieldStart("executedCommission")
			s.ExecutedCommission.Encode(e)
		}
	}
	{
		if s.AciValue.Set {
			e.FieldStart("aciValue")
			s.AciValue.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.InitialSecurityPrice.Set {
			e.FieldStart("initialSecurityPrice")
			s.InitialSecurityPrice.Encode(e)
		}
	}
	{
		if s.OrderType.Set {
			e.FieldStart("orderType")
			s.OrderType.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.InitialOrderPricePt.Set {
			e.FieldStart("initialOrderPricePt")
			s.InitialOrderPricePt.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PostOrderResponse = [17]string{
	0:  "orderId",
	1:  "executionReportStatus",
	2:  "lotsRequested",
	3:  "lotsExecuted",
	4:  "initialOrderPrice",
	5:  "executedOrderPrice",
	6:  "totalOrderAmount",
	7:  "initialCommission",
	8:  "executedCommission",
	9:  "aciValue",
	10: "figi",
	11: "direction",
	12: "initialSecurityPrice",
	13: "orderType",
	14: "message",
	15: "initialOrderPricePt",
	16: "instrumentUid",
}

// Decode decodes V1PostOrderResponse from json.
func (s *V1PostOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PostOrderResponse to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "orderId":
			if err := func() error {
				s.OrderId.Reset()
				if err := s.OrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "executionReportStatus":
			if err := func() error {
				s.ExecutionReportStatus.Reset()
				if err := s.ExecutionReportStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionReportStatus\"")
			}
		case "lotsRequested":
			if err := func() error {
				s.LotsRequested.Reset()
				if err := s.LotsRequested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lotsRequested\"")
			}
		case "lotsExecuted":
			if err := func() error {
				s.LotsExecuted.Reset()
				if err := s.LotsExecuted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lotsExecuted\"")
			}
		case "initialOrderPrice":
			if err := func() error {
				s.InitialOrderPrice.Reset()
				if err := s.InitialOrderPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialOrderPrice\"")
			}
		case "executedOrderPrice":
			if err := func() error {
				s.ExecutedOrderPrice.Reset()
				if err := s.ExecutedOrderPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executedOrderPrice\"")
			}
		case "totalOrderAmount":
			if err := func() error {
				s.TotalOrderAmount.Reset()
				if err := s.TotalOrderAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalOrderAmount\"")
			}
		case "initialCommission":
			if err := func() error {
				s.InitialCommission.Reset()
				if err := s.InitialCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialCommission\"")
			}
		case "executedCommission":
			if err := func() error {
				s.ExecutedCommission.Reset()
				if err := s.ExecutedCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executedCommission\"")
			}
		case "aciValue":
			if err := func() error {
				s.AciValue.Reset()
				if err := s.AciValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aciValue\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "initialSecurityPrice":
			if err := func() error {
				s.InitialSecurityPrice.Reset()
				if err := s.InitialSecurityPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialSecurityPrice\"")
			}
		case "orderType":
			if err := func() error {
				s.OrderType.Reset()
				if err := s.OrderType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderType\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "initialOrderPricePt":
			if err := func() error {
				s.InitialOrderPricePt.Reset()
				if err := s.InitialOrderPricePt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialOrderPricePt\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PostOrderResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PostOrderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PostOrderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PostStopOrderRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PostStopOrderRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.StopPrice.Set {
			e.FieldStart("stopPrice")
			s.StopPrice.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.ExpirationType.Set {
			e.FieldStart("expirationType")
			s.ExpirationType.Encode(e)
		}
	}
	{
		if s.StopOrderType.Set {
			e.FieldStart("stopOrderType")
			s.StopOrderType.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expireDate")
			s.ExpireDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InstrumentId.Set {
			e.FieldStart("instrumentId")
			s.InstrumentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PostStopOrderRequest = [10]string{
	0: "figi",
	1: "quantity",
	2: "price",
	3: "stopPrice",
	4: "direction",
	5: "accountId",
	6: "expirationType",
	7: "stopOrderType",
	8: "expireDate",
	9: "instrumentId",
}

// Decode decodes V1PostStopOrderRequest from json.
func (s *V1PostStopOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PostStopOrderRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "stopPrice":
			if err := func() error {
				s.StopPrice.Reset()
				if err := s.StopPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopPrice\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "expirationType":
			if err := func() error {
				s.ExpirationType.Reset()
				if err := s.ExpirationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationType\"")
			}
		case "stopOrderType":
			if err := func() error {
				s.StopOrderType.Reset()
				if err := s.StopOrderType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopOrderType\"")
			}
		case "expireDate":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireDate\"")
			}
		case "instrumentId":
			if err := func() error {
				s.InstrumentId.Reset()
				if err := s.InstrumentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PostStopOrderRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PostStopOrderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PostStopOrderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1PostStopOrderResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1PostStopOrderResponse) encodeFields(e *jx.Encoder) {
	{
		if s.StopOrderId.Set {
			e.FieldStart("stopOrderId")
			s.StopOrderId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1PostStopOrderResponse = [1]string{
	0: "stopOrderId",
}

// Decode decodes V1PostStopOrderResponse from json.
func (s *V1PostStopOrderResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PostStopOrderResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stopOrderId":
			if err := func() error {
				s.StopOrderId.Reset()
				if err := s.StopOrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopOrderId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1PostStopOrderResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1PostStopOrderResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PostStopOrderResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1PriceType as json.
func (s V1PriceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1PriceType from json.
func (s *V1PriceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1PriceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1PriceType(v) {
	case V1PriceTypePRICETYPEUNSPECIFIED:
		*s = V1PriceTypePRICETYPEUNSPECIFIED
	case V1PriceTypePRICETYPEPOINT:
		*s = V1PriceTypePRICETYPEPOINT
	case V1PriceTypePRICETYPECURRENCY:
		*s = V1PriceTypePRICETYPECURRENCY
	default:
		*s = V1PriceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1PriceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1PriceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Quotation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Quotation) encodeFields(e *jx.Encoder) {
	{
		if s.Units.Set {
			e.FieldStart("units")
			s.Units.Encode(e)
		}
	}
	{
		if s.Nano.Set {
			e.FieldStart("nano")
			s.Nano.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Quotation = [2]string{
	0: "units",
	1: "nano",
}

// Decode decodes V1Quotation from json.
func (s *V1Quotation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Quotation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "units":
			if err := func() error {
				s.Units.Reset()
				if err := s.Units.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"units\"")
			}
		case "nano":
			if err := func() error {
				s.Nano.Reset()
				if err := s.Nano.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nano\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Quotation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Quotation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Quotation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1RealExchange as json.
func (s V1RealExchange) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1RealExchange from json.
func (s *V1RealExchange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1RealExchange to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1RealExchange(v) {
	case V1RealExchangeREALEXCHANGEUNSPECIFIED:
		*s = V1RealExchangeREALEXCHANGEUNSPECIFIED
	case V1RealExchangeREALEXCHANGEMOEX:
		*s = V1RealExchangeREALEXCHANGEMOEX
	case V1RealExchangeREALEXCHANGERTS:
		*s = V1RealExchangeREALEXCHANGERTS
	case V1RealExchangeREALEXCHANGEOTC:
		*s = V1RealExchangeREALEXCHANGEOTC
	default:
		*s = V1RealExchange(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1RealExchange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1RealExchange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1ReplaceOrderRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1ReplaceOrderRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.OrderId.Set {
			e.FieldStart("orderId")
			s.OrderId.Encode(e)
		}
	}
	{
		if s.IdempotencyKey.Set {
			e.FieldStart("idempotencyKey")
			s.IdempotencyKey.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.PriceType.Set {
			e.FieldStart("priceType")
			s.PriceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1ReplaceOrderRequest = [6]string{
	0: "accountId",
	1: "orderId",
	2: "idempotencyKey",
	3: "quantity",
	4: "price",
	5: "priceType",
}

// Decode decodes V1ReplaceOrderRequest from json.
func (s *V1ReplaceOrderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ReplaceOrderRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "orderId":
			if err := func() error {
				s.OrderId.Reset()
				if err := s.OrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderId\"")
			}
		case "idempotencyKey":
			if err := func() error {
				s.IdempotencyKey.Reset()
				if err := s.IdempotencyKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idempotencyKey\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "priceType":
			if err := func() error {
				s.PriceType.Reset()
				if err := s.PriceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1ReplaceOrderRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1ReplaceOrderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ReplaceOrderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1RiskLevel as json.
func (s V1RiskLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1RiskLevel from json.
func (s *V1RiskLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1RiskLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1RiskLevel(v) {
	case V1RiskLevelRISKLEVELUNSPECIFIED:
		*s = V1RiskLevelRISKLEVELUNSPECIFIED
	case V1RiskLevelRISKLEVELLOW:
		*s = V1RiskLevelRISKLEVELLOW
	case V1RiskLevelRISKLEVELMODERATE:
		*s = V1RiskLevelRISKLEVELMODERATE
	case V1RiskLevelRISKLEVELHIGH:
		*s = V1RiskLevelRISKLEVELHIGH
	default:
		*s = V1RiskLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1RiskLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1RiskLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1SandboxPayInRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1SandboxPayInRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1SandboxPayInRequest = [2]string{
	0: "accountId",
	1: "amount",
}

// Decode decodes V1SandboxPayInRequest from json.
func (s *V1SandboxPayInRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1SandboxPayInRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1SandboxPayInRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1SandboxPayInRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1SandboxPayInRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1SandboxPayInResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1SandboxPayInResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1SandboxPayInResponse = [1]string{
	0: "balance",
}

// Decode decodes V1SandboxPayInResponse from json.
func (s *V1SandboxPayInResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1SandboxPayInResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1SandboxPayInResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1SandboxPayInResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1SandboxPayInResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1SecurityTradingStatus as json.
func (s V1SecurityTradingStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1SecurityTradingStatus from json.
func (s *V1SecurityTradingStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1SecurityTradingStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1SecurityTradingStatus(v) {
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSUNSPECIFIED:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSUNSPECIFIED
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSNOTAVAILABLEFORTRADING:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSNOTAVAILABLEFORTRADING
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSOPENINGPERIOD:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSOPENINGPERIOD
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSCLOSINGPERIOD:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSCLOSINGPERIOD
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSBREAKINTRADING:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSBREAKINTRADING
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSNORMALTRADING:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSNORMALTRADING
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSCLOSINGAUCTION:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSCLOSINGAUCTION
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSDARKPOOLAUCTION:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSDARKPOOLAUCTION
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSDISCRETEAUCTION:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSDISCRETEAUCTION
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSOPENINGAUCTIONPERIOD:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSOPENINGAUCTIONPERIOD
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSTRADINGATCLOSINGAUCTIONPRICE:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSTRADINGATCLOSINGAUCTIONPRICE
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSSESSIONASSIGNED:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSSESSIONASSIGNED
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSSESSIONCLOSE:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSSESSIONCLOSE
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSSESSIONOPEN:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSSESSIONOPEN
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSDEALERNORMALTRADING:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSDEALERNORMALTRADING
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSDEALERBREAKINTRADING:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSDEALERBREAKINTRADING
	case V1SecurityTradingStatusSECURITYTRADINGSTATUSDEALERNOTAVAILABLEFORTRADING:
		*s = V1SecurityTradingStatusSECURITYTRADINGSTATUSDEALERNOTAVAILABLEFORTRADING
	default:
		*s = V1SecurityTradingStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1SecurityTradingStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1SecurityTradingStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Share) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Share) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Ticker.Set {
			e.FieldStart("ticker")
			s.Ticker.Encode(e)
		}
	}
	{
		if s.ClassCode.Set {
			e.FieldStart("classCode")
			s.ClassCode.Encode(e)
		}
	}
	{
		if s.Isin.Set {
			e.FieldStart("isin")
			s.Isin.Encode(e)
		}
	}
	{
		if s.Lot.Set {
			e.FieldStart("lot")
			s.Lot.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.Klong.Set {
			e.FieldStart("klong")
			s.Klong.Encode(e)
		}
	}
	{
		if s.Kshort.Set {
			e.FieldStart("kshort")
			s.Kshort.Encode(e)
		}
	}
	{
		if s.Dlong.Set {
			e.FieldStart("dlong")
			s.Dlong.Encode(e)
		}
	}
	{
		if s.Dshort.Set {
			e.FieldStart("dshort")
			s.Dshort.Encode(e)
		}
	}
	{
		if s.DlongMin.Set {
			e.FieldStart("dlongMin")
			s.DlongMin.Encode(e)
		}
	}
	{
		if s.DshortMin.Set {
			e.FieldStart("dshortMin")
			s.DshortMin.Encode(e)
		}
	}
	{
		if s.ShortEnabledFlag.Set {
			e.FieldStart("shortEnabledFlag")
			s.ShortEnabledFlag.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.IpoDate.Set {
			e.FieldStart("ipoDate")
			s.IpoDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IssueSize.Set {
			e.FieldStart("issueSize")
			s.IssueSize.Encode(e)
		}
	}
	{
		if s.CountryOfRisk.Set {
			e.FieldStart("countryOfRisk")
			s.CountryOfRisk.Encode(e)
		}
	}
	{
		if s.CountryOfRiskName.Set {
			e.FieldStart("countryOfRiskName")
			s.CountryOfRiskName.Encode(e)
		}
	}
	{
		if s.Sector.Set {
			e.FieldStart("sector")
			s.Sector.Encode(e)
		}
	}
	{
		if s.IssueSizePlan.Set {
			e.FieldStart("issueSizePlan")
			s.IssueSizePlan.Encode(e)
		}
	}
	{
		if s.Nominal.Set {
			e.FieldStart("nominal")
			s.Nominal.Encode(e)
		}
	}
	{
		if s.TradingStatus.Set {
			e.FieldStart("tradingStatus")
			s.TradingStatus.Encode(e)
		}
	}
	{
		if s.OtcFlag.Set {
			e.FieldStart("otcFlag")
			s.OtcFlag.Encode(e)
		}
	}
	{
		if s.BuyAvailableFlag.Set {
			e.FieldStart("buyAvailableFlag")
			s.BuyAvailableFlag.Encode(e)
		}
	}
	{
		if s.SellAvailableFlag.Set {
			e.FieldStart("sellAvailableFlag")
			s.SellAvailableFlag.Encode(e)
		}
	}
	{
		if s.DivYieldFlag.Set {
			e.FieldStart("divYieldFlag")
			s.DivYieldFlag.Encode(e)
		}
	}
	{
		if s.ShareType.Set {
			e.FieldStart("shareType")
			s.ShareType.Encode(e)
		}
	}
	{
		if s.MinPriceIncrement.Set {
			e.FieldStart("minPriceIncrement")
			s.MinPriceIncrement.Encode(e)
		}
	}
	{
		if s.ApiTradeAvailableFlag.Set {
			e.FieldStart("apiTradeAvailableFlag")
			s.ApiTradeAvailableFlag.Encode(e)
		}
	}
	{
		if s.UID.Set {
			e.FieldStart("uid")
			s.UID.Encode(e)
		}
	}
	{
		if s.RealExchange.Set {
			e.FieldStart("realExchange")
			s.RealExchange.Encode(e)
		}
	}
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.ForIisFlag.Set {
			e.FieldStart("forIisFlag")
			s.ForIisFlag.Encode(e)
		}
	}
	{
		if s.ForQualInvestorFlag.Set {
			e.FieldStart("forQualInvestorFlag")
			s.ForQualInvestorFlag.Encode(e)
		}
	}
	{
		if s.WeekendFlag.Set {
			e.FieldStart("weekendFlag")
			s.WeekendFlag.Encode(e)
		}
	}
	{
		if s.BlockedTcaFlag.Set {
			e.FieldStart("blockedTcaFlag")
			s.BlockedTcaFlag.Encode(e)
		}
	}
	{
		if s.First1minCandleDate.Set {
			e.FieldStart("first1minCandleDate")
			s.First1minCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.First1dayCandleDate.Set {
			e.FieldStart("first1dayCandleDate")
			s.First1dayCandleDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1Share = [39]string{
	0:  "figi",
	1:  "ticker",
	2:  "classCode",
	3:  "isin",
	4:  "lot",
	5:  "currency",
	6:  "klong",
	7:  "kshort",
	8:  "dlong",
	9:  "dshort",
	10: "dlongMin",
	11: "dshortMin",
	12: "shortEnabledFlag",
	13: "name",
	14: "exchange",
	15: "ipoDate",
	16: "issueSize",
	17: "countryOfRisk",
	18: "countryOfRiskName",
	19: "sector",
	20: "issueSizePlan",
	21: "nominal",
	22: "tradingStatus",
	23: "otcFlag",
	24: "buyAvailableFlag",
	25: "sellAvailableFlag",
	26: "divYieldFlag",
	27: "shareType",
	28: "minPriceIncrement",
	29: "apiTradeAvailableFlag",
	30: "uid",
	31: "realExchange",
	32: "positionUid",
	33: "forIisFlag",
	34: "forQualInvestorFlag",
	35: "weekendFlag",
	36: "blockedTcaFlag",
	37: "first1minCandleDate",
	38: "first1dayCandleDate",
}

// Decode decodes V1Share from json.
func (s *V1Share) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Share to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "ticker":
			if err := func() error {
				s.Ticker.Reset()
				if err := s.Ticker.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticker\"")
			}
		case "classCode":
			if err := func() error {
				s.ClassCode.Reset()
				if err := s.ClassCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"classCode\"")
			}
		case "isin":
			if err := func() error {
				s.Isin.Reset()
				if err := s.Isin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isin\"")
			}
		case "lot":
			if err := func() error {
				s.Lot.Reset()
				if err := s.Lot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lot\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "klong":
			if err := func() error {
				s.Klong.Reset()
				if err := s.Klong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"klong\"")
			}
		case "kshort":
			if err := func() error {
				s.Kshort.Reset()
				if err := s.Kshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kshort\"")
			}
		case "dlong":
			if err := func() error {
				s.Dlong.Reset()
				if err := s.Dlong.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlong\"")
			}
		case "dshort":
			if err := func() error {
				s.Dshort.Reset()
				if err := s.Dshort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshort\"")
			}
		case "dlongMin":
			if err := func() error {
				s.DlongMin.Reset()
				if err := s.DlongMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dlongMin\"")
			}
		case "dshortMin":
			if err := func() error {
				s.DshortMin.Reset()
				if err := s.DshortMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dshortMin\"")
			}
		case "shortEnabledFlag":
			if err := func() error {
				s.ShortEnabledFlag.Reset()
				if err := s.ShortEnabledFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortEnabledFlag\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "ipoDate":
			if err := func() error {
				s.IpoDate.Reset()
				if err := s.IpoDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipoDate\"")
			}
		case "issueSize":
			if err := func() error {
				s.IssueSize.Reset()
				if err := s.IssueSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSize\"")
			}
		case "countryOfRisk":
			if err := func() error {
				s.CountryOfRisk.Reset()
				if err := s.CountryOfRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRisk\"")
			}
		case "countryOfRiskName":
			if err := func() error {
				s.CountryOfRiskName.Reset()
				if err := s.CountryOfRiskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryOfRiskName\"")
			}
		case "sector":
			if err := func() error {
				s.Sector.Reset()
				if err := s.Sector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sector\"")
			}
		case "issueSizePlan":
			if err := func() error {
				s.IssueSizePlan.Reset()
				if err := s.IssueSizePlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issueSizePlan\"")
			}
		case "nominal":
			if err := func() error {
				s.Nominal.Reset()
				if err := s.Nominal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nominal\"")
			}
		case "tradingStatus":
			if err := func() error {
				s.TradingStatus.Reset()
				if err := s.TradingStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tradingStatus\"")
			}
		case "otcFlag":
			if err := func() error {
				s.OtcFlag.Reset()
				if err := s.OtcFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otcFlag\"")
			}
		case "buyAvailableFlag":
			if err := func() error {
				s.BuyAvailableFlag.Reset()
				if err := s.BuyAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buyAvailableFlag\"")
			}
		case "sellAvailableFlag":
			if err := func() error {
				s.SellAvailableFlag.Reset()
				if err := s.SellAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sellAvailableFlag\"")
			}
		case "divYieldFlag":
			if err := func() error {
				s.DivYieldFlag.Reset()
				if err := s.DivYieldFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"divYieldFlag\"")
			}
		case "shareType":
			if err := func() error {
				s.ShareType.Reset()
				if err := s.ShareType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shareType\"")
			}
		case "minPriceIncrement":
			if err := func() error {
				s.MinPriceIncrement.Reset()
				if err := s.MinPriceIncrement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minPriceIncrement\"")
			}
		case "apiTradeAvailableFlag":
			if err := func() error {
				s.ApiTradeAvailableFlag.Reset()
				if err := s.ApiTradeAvailableFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiTradeAvailableFlag\"")
			}
		case "uid":
			if err := func() error {
				s.UID.Reset()
				if err := s.UID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uid\"")
			}
		case "realExchange":
			if err := func() error {
				s.RealExchange.Reset()
				if err := s.RealExchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realExchange\"")
			}
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "forIisFlag":
			if err := func() error {
				s.ForIisFlag.Reset()
				if err := s.ForIisFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forIisFlag\"")
			}
		case "forQualInvestorFlag":
			if err := func() error {
				s.ForQualInvestorFlag.Reset()
				if err := s.ForQualInvestorFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forQualInvestorFlag\"")
			}
		case "weekendFlag":
			if err := func() error {
				s.WeekendFlag.Reset()
				if err := s.WeekendFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekendFlag\"")
			}
		case "blockedTcaFlag":
			if err := func() error {
				s.BlockedTcaFlag.Reset()
				if err := s.BlockedTcaFlag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedTcaFlag\"")
			}
		case "first1minCandleDate":
			if err := func() error {
				s.First1minCandleDate.Reset()
				if err := s.First1minCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1minCandleDate\"")
			}
		case "first1dayCandleDate":
			if err := func() error {
				s.First1dayCandleDate.Reset()
				if err := s.First1dayCandleDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first1dayCandleDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Share")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Share) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Share) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1ShareResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1ShareResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instrument.Set {
			e.FieldStart("instrument")
			s.Instrument.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1ShareResponse = [1]string{
	0: "instrument",
}

// Decode decodes V1ShareResponse from json.
func (s *V1ShareResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ShareResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instrument":
			if err := func() error {
				s.Instrument.Reset()
				if err := s.Instrument.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrument\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1ShareResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1ShareResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ShareResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1ShareType as json.
func (s V1ShareType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1ShareType from json.
func (s *V1ShareType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1ShareType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1ShareType(v) {
	case V1ShareTypeSHARETYPEUNSPECIFIED:
		*s = V1ShareTypeSHARETYPEUNSPECIFIED
	case V1ShareTypeSHARETYPECOMMON:
		*s = V1ShareTypeSHARETYPECOMMON
	case V1ShareTypeSHARETYPEPREFERRED:
		*s = V1ShareTypeSHARETYPEPREFERRED
	case V1ShareTypeSHARETYPEADR:
		*s = V1ShareTypeSHARETYPEADR
	case V1ShareTypeSHARETYPEGDR:
		*s = V1ShareTypeSHARETYPEGDR
	case V1ShareTypeSHARETYPEMLP:
		*s = V1ShareTypeSHARETYPEMLP
	case V1ShareTypeSHARETYPENYREGSHRS:
		*s = V1ShareTypeSHARETYPENYREGSHRS
	case V1ShareTypeSHARETYPECLOSEDENDFUND:
		*s = V1ShareTypeSHARETYPECLOSEDENDFUND
	case V1ShareTypeSHARETYPEREIT:
		*s = V1ShareTypeSHARETYPEREIT
	default:
		*s = V1ShareType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1ShareType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1ShareType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1SharesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1SharesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Instruments != nil {
			e.FieldStart("instruments")
			e.ArrStart()
			for _, elem := range s.Instruments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1SharesResponse = [1]string{
	0: "instruments",
}

// Decode decodes V1SharesResponse from json.
func (s *V1SharesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1SharesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instruments":
			if err := func() error {
				s.Instruments = make([]V1Share, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1Share
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instruments = append(s.Instruments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1SharesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1SharesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1SharesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1StopOrder) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1StopOrder) encodeFields(e *jx.Encoder) {
	{
		if s.StopOrderId.Set {
			e.FieldStart("stopOrderId")
			s.StopOrderId.Encode(e)
		}
	}
	{
		if s.LotsRequested.Set {
			e.FieldStart("lotsRequested")
			s.LotsRequested.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		if s.OrderType.Set {
			e.FieldStart("orderType")
			s.OrderType.Encode(e)
		}
	}
	{
		if s.CreateDate.Set {
			e.FieldStart("createDate")
			s.CreateDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ActivationDateTime.Set {
			e.FieldStart("activationDateTime")
			s.ActivationDateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExpirationTime.Set {
			e.FieldStart("expirationTime")
			s.ExpirationTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.StopPrice.Set {
			e.FieldStart("stopPrice")
			s.StopPrice.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1StopOrder = [12]string{
	0:  "stopOrderId",
	1:  "lotsRequested",
	2:  "figi",
	3:  "direction",
	4:  "currency",
	5:  "orderType",
	6:  "createDate",
	7:  "activationDateTime",
	8:  "expirationTime",
	9:  "price",
	10: "stopPrice",
	11: "instrumentUid",
}

// Decode decodes V1StopOrder from json.
func (s *V1StopOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1StopOrder to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stopOrderId":
			if err := func() error {
				s.StopOrderId.Reset()
				if err := s.StopOrderId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopOrderId\"")
			}
		case "lotsRequested":
			if err := func() error {
				s.LotsRequested.Reset()
				if err := s.LotsRequested.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lotsRequested\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "orderType":
			if err := func() error {
				s.OrderType.Reset()
				if err := s.OrderType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orderType\"")
			}
		case "createDate":
			if err := func() error {
				s.CreateDate.Reset()
				if err := s.CreateDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createDate\"")
			}
		case "activationDateTime":
			if err := func() error {
				s.ActivationDateTime.Reset()
				if err := s.ActivationDateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activationDateTime\"")
			}
		case "expirationTime":
			if err := func() error {
				s.ExpirationTime.Reset()
				if err := s.ExpirationTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expirationTime\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "stopPrice":
			if err := func() error {
				s.StopPrice.Reset()
				if err := s.StopPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopPrice\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1StopOrder")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1StopOrder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1StopOrder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StopOrderDirection as json.
func (s V1StopOrderDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1StopOrderDirection from json.
func (s *V1StopOrderDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1StopOrderDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1StopOrderDirection(v) {
	case V1StopOrderDirectionSTOPORDERDIRECTIONUNSPECIFIED:
		*s = V1StopOrderDirectionSTOPORDERDIRECTIONUNSPECIFIED
	case V1StopOrderDirectionSTOPORDERDIRECTIONBUY:
		*s = V1StopOrderDirectionSTOPORDERDIRECTIONBUY
	case V1StopOrderDirectionSTOPORDERDIRECTIONSELL:
		*s = V1StopOrderDirectionSTOPORDERDIRECTIONSELL
	default:
		*s = V1StopOrderDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1StopOrderDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1StopOrderDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StopOrderExpirationType as json.
func (s V1StopOrderExpirationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1StopOrderExpirationType from json.
func (s *V1StopOrderExpirationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1StopOrderExpirationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1StopOrderExpirationType(v) {
	case V1StopOrderExpirationTypeSTOPORDEREXPIRATIONTYPEUNSPECIFIED:
		*s = V1StopOrderExpirationTypeSTOPORDEREXPIRATIONTYPEUNSPECIFIED
	case V1StopOrderExpirationTypeSTOPORDEREXPIRATIONTYPEGOODTILLCANCEL:
		*s = V1StopOrderExpirationTypeSTOPORDEREXPIRATIONTYPEGOODTILLCANCEL
	case V1StopOrderExpirationTypeSTOPORDEREXPIRATIONTYPEGOODTILLDATE:
		*s = V1StopOrderExpirationTypeSTOPORDEREXPIRATIONTYPEGOODTILLDATE
	default:
		*s = V1StopOrderExpirationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1StopOrderExpirationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1StopOrderExpirationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StopOrderType as json.
func (s V1StopOrderType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1StopOrderType from json.
func (s *V1StopOrderType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1StopOrderType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1StopOrderType(v) {
	case V1StopOrderTypeSTOPORDERTYPEUNSPECIFIED:
		*s = V1StopOrderTypeSTOPORDERTYPEUNSPECIFIED
	case V1StopOrderTypeSTOPORDERTYPETAKEPROFIT:
		*s = V1StopOrderTypeSTOPORDERTYPETAKEPROFIT
	case V1StopOrderTypeSTOPORDERTYPESTOPLOSS:
		*s = V1StopOrderTypeSTOPORDERTYPESTOPLOSS
	case V1StopOrderTypeSTOPORDERTYPESTOPLIMIT:
		*s = V1StopOrderTypeSTOPORDERTYPESTOPLIMIT
	default:
		*s = V1StopOrderType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1StopOrderType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1StopOrderType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1StreamLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1StreamLimit) encodeFields(e *jx.Encoder) {
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Streams != nil {
			e.FieldStart("streams")
			e.ArrStart()
			for _, elem := range s.Streams {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1StreamLimit = [2]string{
	0: "limit",
	1: "streams",
}

// Decode decodes V1StreamLimit from json.
func (s *V1StreamLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1StreamLimit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "streams":
			if err := func() error {
				s.Streams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Streams = append(s.Streams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1StreamLimit")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1StreamLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1StreamLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1StructuredProductType as json.
func (s V1StructuredProductType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1StructuredProductType from json.
func (s *V1StructuredProductType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1StructuredProductType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1StructuredProductType(v) {
	case V1StructuredProductTypeSPTYPEUNSPECIFIED:
		*s = V1StructuredProductTypeSPTYPEUNSPECIFIED
	case V1StructuredProductTypeSPTYPEDELIVERABLE:
		*s = V1StructuredProductTypeSPTYPEDELIVERABLE
	case V1StructuredProductTypeSPTYPENONDELIVERABLE:
		*s = V1StructuredProductTypeSPTYPENONDELIVERABLE
	default:
		*s = V1StructuredProductType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1StructuredProductType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1StructuredProductType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1Trade) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1Trade) encodeFields(e *jx.Encoder) {
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1Trade = [6]string{
	0: "figi",
	1: "direction",
	2: "price",
	3: "quantity",
	4: "time",
	5: "instrumentUid",
}

// Decode decodes V1Trade from json.
func (s *V1Trade) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1Trade to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1Trade")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1Trade) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1Trade) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes V1TradeDirection as json.
func (s V1TradeDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes V1TradeDirection from json.
func (s *V1TradeDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1TradeDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch V1TradeDirection(v) {
	case V1TradeDirectionTRADEDIRECTIONUNSPECIFIED:
		*s = V1TradeDirectionTRADEDIRECTIONUNSPECIFIED
	case V1TradeDirectionTRADEDIRECTIONBUY:
		*s = V1TradeDirectionTRADEDIRECTIONBUY
	case V1TradeDirectionTRADEDIRECTIONSELL:
		*s = V1TradeDirectionTRADEDIRECTIONSELL
	default:
		*s = V1TradeDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s V1TradeDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1TradeDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1TradingDay) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1TradingDay) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IsTradingDay.Set {
			e.FieldStart("isTradingDay")
			s.IsTradingDay.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("startTime")
			s.StartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OpeningAuctionStartTime.Set {
			e.FieldStart("openingAuctionStartTime")
			s.OpeningAuctionStartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ClosingAuctionEndTime.Set {
			e.FieldStart("closingAuctionEndTime")
			s.ClosingAuctionEndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EveningOpeningAuctionStartTime.Set {
			e.FieldStart("eveningOpeningAuctionStartTime")
			s.EveningOpeningAuctionStartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EveningStartTime.Set {
			e.FieldStart("eveningStartTime")
			s.EveningStartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EveningEndTime.Set {
			e.FieldStart("eveningEndTime")
			s.EveningEndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ClearingStartTime.Set {
			e.FieldStart("clearingStartTime")
			s.ClearingStartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ClearingEndTime.Set {
			e.FieldStart("clearingEndTime")
			s.ClearingEndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PremarketStartTime.Set {
			e.FieldStart("premarketStartTime")
			s.PremarketStartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PremarketEndTime.Set {
			e.FieldStart("premarketEndTime")
			s.PremarketEndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ClosingAuctionStartTime.Set {
			e.FieldStart("closingAuctionStartTime")
			s.ClosingAuctionStartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.OpeningAuctionEndTime.Set {
			e.FieldStart("openingAuctionEndTime")
			s.OpeningAuctionEndTime.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1TradingDay = [15]string{
	0:  "date",
	1:  "isTradingDay",
	2:  "startTime",
	3:  "endTime",
	4:  "openingAuctionStartTime",
	5:  "closingAuctionEndTime",
	6:  "eveningOpeningAuctionStartTime",
	7:  "eveningStartTime",
	8:  "eveningEndTime",
	9:  "clearingStartTime",
	10: "clearingEndTime",
	11: "premarketStartTime",
	12: "premarketEndTime",
	13: "closingAuctionStartTime",
	14: "openingAuctionEndTime",
}

// Decode decodes V1TradingDay from json.
func (s *V1TradingDay) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1TradingDay to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "isTradingDay":
			if err := func() error {
				s.IsTradingDay.Reset()
				if err := s.IsTradingDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTradingDay\"")
			}
		case "startTime":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "openingAuctionStartTime":
			if err := func() error {
				s.OpeningAuctionStartTime.Reset()
				if err := s.OpeningAuctionStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openingAuctionStartTime\"")
			}
		case "closingAuctionEndTime":
			if err := func() error {
				s.ClosingAuctionEndTime.Reset()
				if err := s.ClosingAuctionEndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closingAuctionEndTime\"")
			}
		case "eveningOpeningAuctionStartTime":
			if err := func() error {
				s.EveningOpeningAuctionStartTime.Reset()
				if err := s.EveningOpeningAuctionStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eveningOpeningAuctionStartTime\"")
			}
		case "eveningStartTime":
			if err := func() error {
				s.EveningStartTime.Reset()
				if err := s.EveningStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eveningStartTime\"")
			}
		case "eveningEndTime":
			if err := func() error {
				s.EveningEndTime.Reset()
				if err := s.EveningEndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eveningEndTime\"")
			}
		case "clearingStartTime":
			if err := func() error {
				s.ClearingStartTime.Reset()
				if err := s.ClearingStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clearingStartTime\"")
			}
		case "clearingEndTime":
			if err := func() error {
				s.ClearingEndTime.Reset()
				if err := s.ClearingEndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clearingEndTime\"")
			}
		case "premarketStartTime":
			if err := func() error {
				s.PremarketStartTime.Reset()
				if err := s.PremarketStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premarketStartTime\"")
			}
		case "premarketEndTime":
			if err := func() error {
				s.PremarketEndTime.Reset()
				if err := s.PremarketEndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premarketEndTime\"")
			}
		case "closingAuctionStartTime":
			if err := func() error {
				s.ClosingAuctionStartTime.Reset()
				if err := s.ClosingAuctionStartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closingAuctionStartTime\"")
			}
		case "openingAuctionEndTime":
			if err := func() error {
				s.OpeningAuctionEndTime.Reset()
				if err := s.OpeningAuctionEndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openingAuctionEndTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1TradingDay")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1TradingDay) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1TradingDay) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1TradingSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1TradingSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.Days != nil {
			e.FieldStart("days")
			e.ArrStart()
			for _, elem := range s.Days {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1TradingSchedule = [2]string{
	0: "exchange",
	1: "days",
}

// Decode decodes V1TradingSchedule from json.
func (s *V1TradingSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1TradingSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "days":
			if err := func() error {
				s.Days = make([]V1TradingDay, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1TradingDay
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Days = append(s.Days, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"days\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1TradingSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1TradingSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1TradingSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1TradingSchedulesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1TradingSchedulesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Exchange.Set {
			e.FieldStart("exchange")
			s.Exchange.Encode(e)
		}
	}
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfV1TradingSchedulesRequest = [3]string{
	0: "exchange",
	1: "from",
	2: "to",
}

// Decode decodes V1TradingSchedulesRequest from json.
func (s *V1TradingSchedulesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1TradingSchedulesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exchange":
			if err := func() error {
				s.Exchange.Reset()
				if err := s.Exchange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchange\"")
			}
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1TradingSchedulesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1TradingSchedulesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1TradingSchedulesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1TradingSchedulesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1TradingSchedulesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Exchanges != nil {
			e.FieldStart("exchanges")
			e.ArrStart()
			for _, elem := range s.Exchanges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1TradingSchedulesResponse = [1]string{
	0: "exchanges",
}

// Decode decodes V1TradingSchedulesResponse from json.
func (s *V1TradingSchedulesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1TradingSchedulesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exchanges":
			if err := func() error {
				s.Exchanges = make([]V1TradingSchedule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1TradingSchedule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Exchanges = append(s.Exchanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exchanges\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1TradingSchedulesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1TradingSchedulesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1TradingSchedulesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1UnaryLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1UnaryLimit) encodeFields(e *jx.Encoder) {
	{
		if s.LimitPerMinute.Set {
			e.FieldStart("limitPerMinute")
			s.LimitPerMinute.Encode(e)
		}
	}
	{
		if s.Methods != nil {
			e.FieldStart("methods")
			e.ArrStart()
			for _, elem := range s.Methods {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1UnaryLimit = [2]string{
	0: "limitPerMinute",
	1: "methods",
}

// Decode decodes V1UnaryLimit from json.
func (s *V1UnaryLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1UnaryLimit to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limitPerMinute":
			if err := func() error {
				s.LimitPerMinute.Reset()
				if err := s.LimitPerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitPerMinute\"")
			}
		case "methods":
			if err := func() error {
				s.Methods = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Methods = append(s.Methods, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"methods\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1UnaryLimit")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1UnaryLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1UnaryLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1VirtualPortfolioPosition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1VirtualPortfolioPosition) encodeFields(e *jx.Encoder) {
	{
		if s.PositionUid.Set {
			e.FieldStart("positionUid")
			s.PositionUid.Encode(e)
		}
	}
	{
		if s.InstrumentUid.Set {
			e.FieldStart("instrumentUid")
			s.InstrumentUid.Encode(e)
		}
	}
	{
		if s.Figi.Set {
			e.FieldStart("figi")
			s.Figi.Encode(e)
		}
	}
	{
		if s.InstrumentType.Set {
			e.FieldStart("instrumentType")
			s.InstrumentType.Encode(e)
		}
	}
	{
		if s.Quantity.Set {
			e.FieldStart("quantity")
			s.Quantity.Encode(e)
		}
	}
	{
		if s.AveragePositionPrice.Set {
			e.FieldStart("averagePositionPrice")
			s.AveragePositionPrice.Encode(e)
		}
	}
	{
		if s.ExpectedYield.Set {
			e.FieldStart("expectedYield")
			s.ExpectedYield.Encode(e)
		}
	}
	{
		if s.ExpectedYieldFifo.Set {
			e.FieldStart("expectedYieldFifo")
			s.ExpectedYieldFifo.Encode(e)
		}
	}
	{
		if s.ExpireDate.Set {
			e.FieldStart("expireDate")
			s.ExpireDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CurrentPrice.Set {
			e.FieldStart("currentPrice")
			s.CurrentPrice.Encode(e)
		}
	}
	{
		if s.AveragePositionPriceFifo.Set {
			e.FieldStart("averagePositionPriceFifo")
			s.AveragePositionPriceFifo.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1VirtualPortfolioPosition = [11]string{
	0:  "positionUid",
	1:  "instrumentUid",
	2:  "figi",
	3:  "instrumentType",
	4:  "quantity",
	5:  "averagePositionPrice",
	6:  "expectedYield",
	7:  "expectedYieldFifo",
	8:  "expireDate",
	9:  "currentPrice",
	10: "averagePositionPriceFifo",
}

// Decode decodes V1VirtualPortfolioPosition from json.
func (s *V1VirtualPortfolioPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1VirtualPortfolioPosition to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "positionUid":
			if err := func() error {
				s.PositionUid.Reset()
				if err := s.PositionUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positionUid\"")
			}
		case "instrumentUid":
			if err := func() error {
				s.InstrumentUid.Reset()
				if err := s.InstrumentUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentUid\"")
			}
		case "figi":
			if err := func() error {
				s.Figi.Reset()
				if err := s.Figi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"figi\"")
			}
		case "instrumentType":
			if err := func() error {
				s.InstrumentType.Reset()
				if err := s.InstrumentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instrumentType\"")
			}
		case "quantity":
			if err := func() error {
				s.Quantity.Reset()
				if err := s.Quantity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quantity\"")
			}
		case "averagePositionPrice":
			if err := func() error {
				s.AveragePositionPrice.Reset()
				if err := s.AveragePositionPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPrice\"")
			}
		case "expectedYield":
			if err := func() error {
				s.ExpectedYield.Reset()
				if err := s.ExpectedYield.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedYield\"")
			}
		case "expectedYieldFifo":
			if err := func() error {
				s.ExpectedYieldFifo.Reset()
				if err := s.ExpectedYieldFifo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedYieldFifo\"")
			}
		case "expireDate":
			if err := func() error {
				s.ExpireDate.Reset()
				if err := s.ExpireDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireDate\"")
			}
		case "currentPrice":
			if err := func() error {
				s.CurrentPrice.Reset()
				if err := s.CurrentPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentPrice\"")
			}
		case "averagePositionPriceFifo":
			if err := func() error {
				s.AveragePositionPriceFifo.Reset()
				if err := s.AveragePositionPriceFifo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averagePositionPriceFifo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1VirtualPortfolioPosition")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1VirtualPortfolioPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1VirtualPortfolioPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1WithdrawLimitsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1WithdrawLimitsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
}

var jsonFieldsNameOfV1WithdrawLimitsRequest = [1]string{
	0: "accountId",
}

// Decode decodes V1WithdrawLimitsRequest from json.
func (s *V1WithdrawLimitsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1WithdrawLimitsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1WithdrawLimitsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1WithdrawLimitsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1WithdrawLimitsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *V1WithdrawLimitsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *V1WithdrawLimitsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Money != nil {
			e.FieldStart("money")
			e.ArrStart()
			for _, elem := range s.Money {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Blocked != nil {
			e.FieldStart("blocked")
			e.ArrStart()
			for _, elem := range s.Blocked {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BlockedGuarantee != nil {
			e.FieldStart("blockedGuarantee")
			e.ArrStart()
			for _, elem := range s.BlockedGuarantee {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfV1WithdrawLimitsResponse = [3]string{
	0: "money",
	1: "blocked",
	2: "blockedGuarantee",
}

// Decode decodes V1WithdrawLimitsResponse from json.
func (s *V1WithdrawLimitsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode V1WithdrawLimitsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "money":
			if err := func() error {
				s.Money = make([]V1MoneyValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1MoneyValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Money = append(s.Money, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"money\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked = make([]V1MoneyValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1MoneyValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Blocked = append(s.Blocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "blockedGuarantee":
			if err := func() error {
				s.BlockedGuarantee = make([]V1MoneyValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem V1MoneyValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BlockedGuarantee = append(s.BlockedGuarantee, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blockedGuarantee\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode V1WithdrawLimitsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *V1WithdrawLimitsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *V1WithdrawLimitsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
