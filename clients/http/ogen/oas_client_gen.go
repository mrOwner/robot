// Code generated by ogen, DO NOT EDIT.

package ogen

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// InstrumentsServiceBondBy invokes InstrumentsService_BondBy operation.
//
// Метод получения облигации по её идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/BondBy
func (c *Client) InstrumentsServiceBondBy(ctx context.Context, request *V1InstrumentRequest) (InstrumentsServiceBondByRes, error) {
	res, err := c.sendInstrumentsServiceBondBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceBondBy(ctx context.Context, request *V1InstrumentRequest) (res InstrumentsServiceBondByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_BondBy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceBondBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/BondBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceBondByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceBondBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceBondByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceBonds invokes InstrumentsService_Bonds operation.
//
// Метод получения списка облигаций.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/Bonds
func (c *Client) InstrumentsServiceBonds(ctx context.Context, request *V1InstrumentsRequest) (InstrumentsServiceBondsRes, error) {
	res, err := c.sendInstrumentsServiceBonds(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceBonds(ctx context.Context, request *V1InstrumentsRequest) (res InstrumentsServiceBondsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_Bonds"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceBonds",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Bonds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceBondsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceBonds", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceBondsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceCurrencies invokes InstrumentsService_Currencies operation.
//
// Метод получения списка валют.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/Currencies
func (c *Client) InstrumentsServiceCurrencies(ctx context.Context, request *V1InstrumentsRequest) (InstrumentsServiceCurrenciesRes, error) {
	res, err := c.sendInstrumentsServiceCurrencies(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceCurrencies(ctx context.Context, request *V1InstrumentsRequest) (res InstrumentsServiceCurrenciesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_Currencies"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceCurrencies",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Currencies"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceCurrenciesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceCurrencies", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceCurrenciesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceCurrencyBy invokes InstrumentsService_CurrencyBy operation.
//
// Метод получения валюты по её идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/CurrencyBy
func (c *Client) InstrumentsServiceCurrencyBy(ctx context.Context, request *V1InstrumentRequest) (InstrumentsServiceCurrencyByRes, error) {
	res, err := c.sendInstrumentsServiceCurrencyBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceCurrencyBy(ctx context.Context, request *V1InstrumentRequest) (res InstrumentsServiceCurrencyByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_CurrencyBy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceCurrencyBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/CurrencyBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceCurrencyByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceCurrencyBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceCurrencyByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceEditFavorites invokes InstrumentsService_EditFavorites operation.
//
// Метод редактирования списка избранных инструментов.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/EditFavorites
func (c *Client) InstrumentsServiceEditFavorites(ctx context.Context, request *V1EditFavoritesRequest) (InstrumentsServiceEditFavoritesRes, error) {
	res, err := c.sendInstrumentsServiceEditFavorites(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceEditFavorites(ctx context.Context, request *V1EditFavoritesRequest) (res InstrumentsServiceEditFavoritesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_EditFavorites"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceEditFavorites",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/EditFavorites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceEditFavoritesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceEditFavorites", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceEditFavoritesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceEtfBy invokes InstrumentsService_EtfBy operation.
//
// Метод получения инвестиционного фонда по его
// идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/EtfBy
func (c *Client) InstrumentsServiceEtfBy(ctx context.Context, request *V1InstrumentRequest) (InstrumentsServiceEtfByRes, error) {
	res, err := c.sendInstrumentsServiceEtfBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceEtfBy(ctx context.Context, request *V1InstrumentRequest) (res InstrumentsServiceEtfByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_EtfBy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceEtfBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/EtfBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceEtfByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceEtfBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceEtfByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceEtfs invokes InstrumentsService_Etfs operation.
//
// Метод получения списка инвестиционных фондов.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/Etfs
func (c *Client) InstrumentsServiceEtfs(ctx context.Context, request *V1InstrumentsRequest) (InstrumentsServiceEtfsRes, error) {
	res, err := c.sendInstrumentsServiceEtfs(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceEtfs(ctx context.Context, request *V1InstrumentsRequest) (res InstrumentsServiceEtfsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_Etfs"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceEtfs",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Etfs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceEtfsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceEtfs", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceEtfsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceFindInstrument invokes InstrumentsService_FindInstrument operation.
//
// Метод поиска инструмента.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/FindInstrument
func (c *Client) InstrumentsServiceFindInstrument(ctx context.Context, request *V1FindInstrumentRequest) (InstrumentsServiceFindInstrumentRes, error) {
	res, err := c.sendInstrumentsServiceFindInstrument(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceFindInstrument(ctx context.Context, request *V1FindInstrumentRequest) (res InstrumentsServiceFindInstrumentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_FindInstrument"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceFindInstrument",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/FindInstrument"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceFindInstrumentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceFindInstrument", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceFindInstrumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceFutureBy invokes InstrumentsService_FutureBy operation.
//
// Метод получения фьючерса по его идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/FutureBy
func (c *Client) InstrumentsServiceFutureBy(ctx context.Context, request *V1InstrumentRequest) (InstrumentsServiceFutureByRes, error) {
	res, err := c.sendInstrumentsServiceFutureBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceFutureBy(ctx context.Context, request *V1InstrumentRequest) (res InstrumentsServiceFutureByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_FutureBy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceFutureBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/FutureBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceFutureByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceFutureBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceFutureByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceFutures invokes InstrumentsService_Futures operation.
//
// Метод получения списка фьючерсов.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/Futures
func (c *Client) InstrumentsServiceFutures(ctx context.Context, request *V1InstrumentsRequest) (InstrumentsServiceFuturesRes, error) {
	res, err := c.sendInstrumentsServiceFutures(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceFutures(ctx context.Context, request *V1InstrumentsRequest) (res InstrumentsServiceFuturesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_Futures"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceFutures",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Futures"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceFuturesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceFutures", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceFuturesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetAccruedInterests invokes InstrumentsService_GetAccruedInterests operation.
//
// Метод получения накопленного купонного дохода по
// облигации.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAccruedInterests
func (c *Client) InstrumentsServiceGetAccruedInterests(ctx context.Context, request *V1GetAccruedInterestsRequest) (InstrumentsServiceGetAccruedInterestsRes, error) {
	res, err := c.sendInstrumentsServiceGetAccruedInterests(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetAccruedInterests(ctx context.Context, request *V1GetAccruedInterestsRequest) (res InstrumentsServiceGetAccruedInterestsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetAccruedInterests"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetAccruedInterests",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAccruedInterests"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetAccruedInterestsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetAccruedInterests", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetAccruedInterestsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetAssetBy invokes InstrumentsService_GetAssetBy operation.
//
// Метод получения актива по его идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssetBy
func (c *Client) InstrumentsServiceGetAssetBy(ctx context.Context, request *V1AssetRequest) (InstrumentsServiceGetAssetByRes, error) {
	res, err := c.sendInstrumentsServiceGetAssetBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetAssetBy(ctx context.Context, request *V1AssetRequest) (res InstrumentsServiceGetAssetByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetAssetBy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetAssetBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssetBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetAssetByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetAssetBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetAssetByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetAssets invokes InstrumentsService_GetAssets operation.
//
// Метод получения списка активов.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssets
func (c *Client) InstrumentsServiceGetAssets(ctx context.Context, request *V1AssetsRequest) (InstrumentsServiceGetAssetsRes, error) {
	res, err := c.sendInstrumentsServiceGetAssets(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetAssets(ctx context.Context, request *V1AssetsRequest) (res InstrumentsServiceGetAssetsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetAssets"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetAssets",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetAssets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetAssetsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetAssets", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetAssetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetBondCoupons invokes InstrumentsService_GetBondCoupons operation.
//
// Метод получения графика выплат купонов по облигации.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBondCoupons
func (c *Client) InstrumentsServiceGetBondCoupons(ctx context.Context, request *V1GetBondCouponsRequest) (InstrumentsServiceGetBondCouponsRes, error) {
	res, err := c.sendInstrumentsServiceGetBondCoupons(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetBondCoupons(ctx context.Context, request *V1GetBondCouponsRequest) (res InstrumentsServiceGetBondCouponsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetBondCoupons"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetBondCoupons",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBondCoupons"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetBondCouponsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetBondCoupons", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetBondCouponsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetBrandBy invokes InstrumentsService_GetBrandBy operation.
//
// Метод получения бренда по его идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBrandBy
func (c *Client) InstrumentsServiceGetBrandBy(ctx context.Context, request *V1GetBrandRequest) (InstrumentsServiceGetBrandByRes, error) {
	res, err := c.sendInstrumentsServiceGetBrandBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetBrandBy(ctx context.Context, request *V1GetBrandRequest) (res InstrumentsServiceGetBrandByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetBrandBy"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetBrandBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBrandBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetBrandByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetBrandBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetBrandByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetBrands invokes InstrumentsService_GetBrands operation.
//
// Метод получения списка брендов.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBrands
func (c *Client) InstrumentsServiceGetBrands(ctx context.Context, request *V1GetBrandsRequest) (InstrumentsServiceGetBrandsRes, error) {
	res, err := c.sendInstrumentsServiceGetBrands(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetBrands(ctx context.Context, request *V1GetBrandsRequest) (res InstrumentsServiceGetBrandsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetBrands"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetBrands",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetBrands"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetBrandsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetBrands", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetBrandsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetCountries invokes InstrumentsService_GetCountries operation.
//
// Метод получения списка стран.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetCountries
func (c *Client) InstrumentsServiceGetCountries(ctx context.Context, request *V1GetCountriesRequest) (InstrumentsServiceGetCountriesRes, error) {
	res, err := c.sendInstrumentsServiceGetCountries(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetCountries(ctx context.Context, request *V1GetCountriesRequest) (res InstrumentsServiceGetCountriesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetCountries"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetCountries",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetCountries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetCountriesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetCountries", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetCountriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetDividends invokes InstrumentsService_GetDividends operation.
//
// Метод для получения событий выплаты дивидендов по
// инструменту.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetDividends
func (c *Client) InstrumentsServiceGetDividends(ctx context.Context, request *V1GetDividendsRequest) (InstrumentsServiceGetDividendsRes, error) {
	res, err := c.sendInstrumentsServiceGetDividends(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetDividends(ctx context.Context, request *V1GetDividendsRequest) (res InstrumentsServiceGetDividendsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetDividends"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetDividends",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetDividends"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetDividendsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetDividends", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetDividendsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetFavorites invokes InstrumentsService_GetFavorites operation.
//
// Метод получения списка избранных инструментов.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFavorites
func (c *Client) InstrumentsServiceGetFavorites(ctx context.Context, request *V1GetFavoritesRequest) (InstrumentsServiceGetFavoritesRes, error) {
	res, err := c.sendInstrumentsServiceGetFavorites(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetFavorites(ctx context.Context, request *V1GetFavoritesRequest) (res InstrumentsServiceGetFavoritesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetFavorites"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetFavorites",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFavorites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetFavoritesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetFavorites", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetFavoritesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetFuturesMargin invokes InstrumentsService_GetFuturesMargin operation.
//
// Метод получения размера гарантийного обеспечения по
// фьючерсам.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFuturesMargin
func (c *Client) InstrumentsServiceGetFuturesMargin(ctx context.Context, request *V1GetFuturesMarginRequest) (InstrumentsServiceGetFuturesMarginRes, error) {
	res, err := c.sendInstrumentsServiceGetFuturesMargin(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetFuturesMargin(ctx context.Context, request *V1GetFuturesMarginRequest) (res InstrumentsServiceGetFuturesMarginRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetFuturesMargin"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetFuturesMargin",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetFuturesMargin"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetFuturesMarginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetFuturesMargin", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetFuturesMarginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceGetInstrumentBy invokes InstrumentsService_GetInstrumentBy operation.
//
// Метод получения основной информации об инструменте.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/GetInstrumentBy
func (c *Client) InstrumentsServiceGetInstrumentBy(ctx context.Context, request *V1InstrumentRequest) (InstrumentsServiceGetInstrumentByRes, error) {
	res, err := c.sendInstrumentsServiceGetInstrumentBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceGetInstrumentBy(ctx context.Context, request *V1InstrumentRequest) (res InstrumentsServiceGetInstrumentByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_GetInstrumentBy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceGetInstrumentBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/GetInstrumentBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceGetInstrumentByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceGetInstrumentBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceGetInstrumentByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceOptionBy invokes InstrumentsService_OptionBy operation.
//
// Метод получения опциона по его идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/OptionBy
func (c *Client) InstrumentsServiceOptionBy(ctx context.Context, request *V1InstrumentRequest) (InstrumentsServiceOptionByRes, error) {
	res, err := c.sendInstrumentsServiceOptionBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceOptionBy(ctx context.Context, request *V1InstrumentRequest) (res InstrumentsServiceOptionByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_OptionBy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceOptionBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/OptionBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceOptionByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceOptionBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceOptionByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceOptions invokes InstrumentsService_Options operation.
//
// Метод получения списка опционов.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/Options
func (c *Client) InstrumentsServiceOptions(ctx context.Context, request *V1InstrumentsRequest) (InstrumentsServiceOptionsRes, error) {
	res, err := c.sendInstrumentsServiceOptions(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceOptions(ctx context.Context, request *V1InstrumentsRequest) (res InstrumentsServiceOptionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_Options"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceOptions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Options"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceOptionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceOptions", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceOptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceShareBy invokes InstrumentsService_ShareBy operation.
//
// Метод получения акции по её идентификатору.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/ShareBy
func (c *Client) InstrumentsServiceShareBy(ctx context.Context, request *V1InstrumentRequest) (InstrumentsServiceShareByRes, error) {
	res, err := c.sendInstrumentsServiceShareBy(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceShareBy(ctx context.Context, request *V1InstrumentRequest) (res InstrumentsServiceShareByRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_ShareBy"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceShareBy",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/ShareBy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceShareByRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceShareBy", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceShareByResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceShares invokes InstrumentsService_Shares operation.
//
// Метод получения списка акций.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/Shares
func (c *Client) InstrumentsServiceShares(ctx context.Context, request *V1InstrumentsRequest) (InstrumentsServiceSharesRes, error) {
	res, err := c.sendInstrumentsServiceShares(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceShares(ctx context.Context, request *V1InstrumentsRequest) (res InstrumentsServiceSharesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_Shares"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceShares",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/Shares"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceSharesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceShares", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceSharesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsServiceTradingSchedules invokes InstrumentsService_TradingSchedules operation.
//
// Метод получения расписания торгов торговых площадок.
//
// POST /tinkoff.public.invest.api.contract.v1.InstrumentsService/TradingSchedules
func (c *Client) InstrumentsServiceTradingSchedules(ctx context.Context, request *V1TradingSchedulesRequest) (InstrumentsServiceTradingSchedulesRes, error) {
	res, err := c.sendInstrumentsServiceTradingSchedules(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendInstrumentsServiceTradingSchedules(ctx context.Context, request *V1TradingSchedulesRequest) (res InstrumentsServiceTradingSchedulesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsService_TradingSchedules"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsServiceTradingSchedules",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.InstrumentsService/TradingSchedules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentsServiceTradingSchedulesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "InstrumentsServiceTradingSchedules", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsServiceTradingSchedulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarketDataServiceGetCandles invokes MarketDataService_GetCandles operation.
//
// Метод запроса исторических свечей по инструменту.
//
// POST /tinkoff.public.invest.api.contract.v1.MarketDataService/GetCandles
func (c *Client) MarketDataServiceGetCandles(ctx context.Context, request *V1GetCandlesRequest) (MarketDataServiceGetCandlesRes, error) {
	res, err := c.sendMarketDataServiceGetCandles(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendMarketDataServiceGetCandles(ctx context.Context, request *V1GetCandlesRequest) (res MarketDataServiceGetCandlesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarketDataService_GetCandles"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarketDataServiceGetCandles",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetCandles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarketDataServiceGetCandlesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "MarketDataServiceGetCandles", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarketDataServiceGetCandlesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarketDataServiceGetClosePrices invokes MarketDataService_GetClosePrices operation.
//
// Метод запроса цен закрытия торговой сессии по
// инструментам.
//
// POST /tinkoff.public.invest.api.contract.v1.MarketDataService/GetClosePrices
func (c *Client) MarketDataServiceGetClosePrices(ctx context.Context, request *V1GetClosePricesRequest) (MarketDataServiceGetClosePricesRes, error) {
	res, err := c.sendMarketDataServiceGetClosePrices(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendMarketDataServiceGetClosePrices(ctx context.Context, request *V1GetClosePricesRequest) (res MarketDataServiceGetClosePricesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarketDataService_GetClosePrices"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarketDataServiceGetClosePrices",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetClosePrices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarketDataServiceGetClosePricesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "MarketDataServiceGetClosePrices", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarketDataServiceGetClosePricesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarketDataServiceGetLastPrices invokes MarketDataService_GetLastPrices operation.
//
// Метод запроса цен последних сделок по инструментам.
//
// POST /tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastPrices
func (c *Client) MarketDataServiceGetLastPrices(ctx context.Context, request *V1GetLastPricesRequest) (MarketDataServiceGetLastPricesRes, error) {
	res, err := c.sendMarketDataServiceGetLastPrices(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendMarketDataServiceGetLastPrices(ctx context.Context, request *V1GetLastPricesRequest) (res MarketDataServiceGetLastPricesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarketDataService_GetLastPrices"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarketDataServiceGetLastPrices",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastPrices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarketDataServiceGetLastPricesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "MarketDataServiceGetLastPrices", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarketDataServiceGetLastPricesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarketDataServiceGetLastTrades invokes MarketDataService_GetLastTrades operation.
//
// Метод запроса обезличенных сделок за последний час.
//
// POST /tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastTrades
func (c *Client) MarketDataServiceGetLastTrades(ctx context.Context, request *V1GetLastTradesRequest) (MarketDataServiceGetLastTradesRes, error) {
	res, err := c.sendMarketDataServiceGetLastTrades(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendMarketDataServiceGetLastTrades(ctx context.Context, request *V1GetLastTradesRequest) (res MarketDataServiceGetLastTradesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarketDataService_GetLastTrades"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarketDataServiceGetLastTrades",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetLastTrades"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarketDataServiceGetLastTradesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "MarketDataServiceGetLastTrades", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarketDataServiceGetLastTradesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarketDataServiceGetOrderBook invokes MarketDataService_GetOrderBook operation.
//
// Метод получения стакана по инструменту.
//
// POST /tinkoff.public.invest.api.contract.v1.MarketDataService/GetOrderBook
func (c *Client) MarketDataServiceGetOrderBook(ctx context.Context, request *V1GetOrderBookRequest) (MarketDataServiceGetOrderBookRes, error) {
	res, err := c.sendMarketDataServiceGetOrderBook(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendMarketDataServiceGetOrderBook(ctx context.Context, request *V1GetOrderBookRequest) (res MarketDataServiceGetOrderBookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarketDataService_GetOrderBook"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarketDataServiceGetOrderBook",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetOrderBook"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarketDataServiceGetOrderBookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "MarketDataServiceGetOrderBook", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarketDataServiceGetOrderBookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarketDataServiceGetTradingStatus invokes MarketDataService_GetTradingStatus operation.
//
// Метод запроса статуса торгов по инструментам.
//
// POST /tinkoff.public.invest.api.contract.v1.MarketDataService/GetTradingStatus
func (c *Client) MarketDataServiceGetTradingStatus(ctx context.Context, request *V1GetTradingStatusRequest) (MarketDataServiceGetTradingStatusRes, error) {
	res, err := c.sendMarketDataServiceGetTradingStatus(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendMarketDataServiceGetTradingStatus(ctx context.Context, request *V1GetTradingStatusRequest) (res MarketDataServiceGetTradingStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarketDataService_GetTradingStatus"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarketDataServiceGetTradingStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetTradingStatus"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarketDataServiceGetTradingStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "MarketDataServiceGetTradingStatus", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarketDataServiceGetTradingStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MarketDataServiceGetTradingStatuses invokes MarketDataService_GetTradingStatuses operation.
//
// Метод запроса статуса торгов по инструментам.
//
// POST /tinkoff.public.invest.api.contract.v1.MarketDataService/GetTradingStatuses
func (c *Client) MarketDataServiceGetTradingStatuses(ctx context.Context, request *V1GetTradingStatusesRequest) (MarketDataServiceGetTradingStatusesRes, error) {
	res, err := c.sendMarketDataServiceGetTradingStatuses(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendMarketDataServiceGetTradingStatuses(ctx context.Context, request *V1GetTradingStatusesRequest) (res MarketDataServiceGetTradingStatusesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("MarketDataService_GetTradingStatuses"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "MarketDataServiceGetTradingStatuses",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.MarketDataService/GetTradingStatuses"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMarketDataServiceGetTradingStatusesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "MarketDataServiceGetTradingStatuses", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMarketDataServiceGetTradingStatusesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OperationsServiceGetBrokerReport invokes OperationsService_GetBrokerReport operation.
//
// Метод получения брокерского отчёта.
//
// POST /tinkoff.public.invest.api.contract.v1.OperationsService/GetBrokerReport
func (c *Client) OperationsServiceGetBrokerReport(ctx context.Context, request *V1BrokerReportRequest) (OperationsServiceGetBrokerReportRes, error) {
	res, err := c.sendOperationsServiceGetBrokerReport(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOperationsServiceGetBrokerReport(ctx context.Context, request *V1BrokerReportRequest) (res OperationsServiceGetBrokerReportRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OperationsService_GetBrokerReport"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OperationsServiceGetBrokerReport",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OperationsService/GetBrokerReport"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOperationsServiceGetBrokerReportRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OperationsServiceGetBrokerReport", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOperationsServiceGetBrokerReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OperationsServiceGetDividendsForeignIssuer invokes OperationsService_GetDividendsForeignIssuer operation.
//
// Метод получения отчёта "Справка о доходах за
// пределами РФ".
//
// POST /tinkoff.public.invest.api.contract.v1.OperationsService/GetDividendsForeignIssuer
func (c *Client) OperationsServiceGetDividendsForeignIssuer(ctx context.Context, request *V1GetDividendsForeignIssuerRequest) (OperationsServiceGetDividendsForeignIssuerRes, error) {
	res, err := c.sendOperationsServiceGetDividendsForeignIssuer(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOperationsServiceGetDividendsForeignIssuer(ctx context.Context, request *V1GetDividendsForeignIssuerRequest) (res OperationsServiceGetDividendsForeignIssuerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OperationsService_GetDividendsForeignIssuer"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OperationsServiceGetDividendsForeignIssuer",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OperationsService/GetDividendsForeignIssuer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOperationsServiceGetDividendsForeignIssuerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OperationsServiceGetDividendsForeignIssuer", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOperationsServiceGetDividendsForeignIssuerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OperationsServiceGetOperations invokes OperationsService_GetOperations operation.
//
// Метод получения списка операций по счёту.При работе с
// данным методом необходимо учитывать
// [особенности взаимодействия](/investAPI/operations_problems) с
// данным методом.
//
// POST /tinkoff.public.invest.api.contract.v1.OperationsService/GetOperations
func (c *Client) OperationsServiceGetOperations(ctx context.Context, request *V1OperationsRequest) (OperationsServiceGetOperationsRes, error) {
	res, err := c.sendOperationsServiceGetOperations(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOperationsServiceGetOperations(ctx context.Context, request *V1OperationsRequest) (res OperationsServiceGetOperationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OperationsService_GetOperations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OperationsServiceGetOperations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OperationsService/GetOperations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOperationsServiceGetOperationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OperationsServiceGetOperations", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOperationsServiceGetOperationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OperationsServiceGetOperationsByCursor invokes OperationsService_GetOperationsByCursor operation.
//
// Метод получения списка операций по счёту с
// пагинацией. При работе с данным методом необходимо
// учитывать
// [особенности взаимодействия](/investAPI/operations_problems) с
// данным методом.
//
// POST /tinkoff.public.invest.api.contract.v1.OperationsService/GetOperationsByCursor
func (c *Client) OperationsServiceGetOperationsByCursor(ctx context.Context, request *V1GetOperationsByCursorRequest) (OperationsServiceGetOperationsByCursorRes, error) {
	res, err := c.sendOperationsServiceGetOperationsByCursor(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOperationsServiceGetOperationsByCursor(ctx context.Context, request *V1GetOperationsByCursorRequest) (res OperationsServiceGetOperationsByCursorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OperationsService_GetOperationsByCursor"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OperationsServiceGetOperationsByCursor",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OperationsService/GetOperationsByCursor"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOperationsServiceGetOperationsByCursorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OperationsServiceGetOperationsByCursor", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOperationsServiceGetOperationsByCursorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OperationsServiceGetPortfolio invokes OperationsService_GetPortfolio operation.
//
// Метод получения портфеля по счёту.
//
// POST /tinkoff.public.invest.api.contract.v1.OperationsService/GetPortfolio
func (c *Client) OperationsServiceGetPortfolio(ctx context.Context, request *V1PortfolioRequest) (OperationsServiceGetPortfolioRes, error) {
	res, err := c.sendOperationsServiceGetPortfolio(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOperationsServiceGetPortfolio(ctx context.Context, request *V1PortfolioRequest) (res OperationsServiceGetPortfolioRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OperationsService_GetPortfolio"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OperationsServiceGetPortfolio",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OperationsService/GetPortfolio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOperationsServiceGetPortfolioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OperationsServiceGetPortfolio", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOperationsServiceGetPortfolioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OperationsServiceGetPositions invokes OperationsService_GetPositions operation.
//
// Метод получения списка позиций по счёту.
//
// POST /tinkoff.public.invest.api.contract.v1.OperationsService/GetPositions
func (c *Client) OperationsServiceGetPositions(ctx context.Context, request *V1PositionsRequest) (OperationsServiceGetPositionsRes, error) {
	res, err := c.sendOperationsServiceGetPositions(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOperationsServiceGetPositions(ctx context.Context, request *V1PositionsRequest) (res OperationsServiceGetPositionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OperationsService_GetPositions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OperationsServiceGetPositions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OperationsService/GetPositions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOperationsServiceGetPositionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OperationsServiceGetPositions", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOperationsServiceGetPositionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OperationsServiceGetWithdrawLimits invokes OperationsService_GetWithdrawLimits operation.
//
// Метод получения доступного остатка для вывода
// средств.
//
// POST /tinkoff.public.invest.api.contract.v1.OperationsService/GetWithdrawLimits
func (c *Client) OperationsServiceGetWithdrawLimits(ctx context.Context, request *V1WithdrawLimitsRequest) (OperationsServiceGetWithdrawLimitsRes, error) {
	res, err := c.sendOperationsServiceGetWithdrawLimits(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOperationsServiceGetWithdrawLimits(ctx context.Context, request *V1WithdrawLimitsRequest) (res OperationsServiceGetWithdrawLimitsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OperationsService_GetWithdrawLimits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OperationsServiceGetWithdrawLimits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OperationsService/GetWithdrawLimits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOperationsServiceGetWithdrawLimitsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OperationsServiceGetWithdrawLimits", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOperationsServiceGetWithdrawLimitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrdersServiceCancelOrder invokes OrdersService_CancelOrder operation.
//
// Метод отмены биржевой заявки.
//
// POST /tinkoff.public.invest.api.contract.v1.OrdersService/CancelOrder
func (c *Client) OrdersServiceCancelOrder(ctx context.Context, request *V1CancelOrderRequest) (OrdersServiceCancelOrderRes, error) {
	res, err := c.sendOrdersServiceCancelOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOrdersServiceCancelOrder(ctx context.Context, request *V1CancelOrderRequest) (res OrdersServiceCancelOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OrdersService_CancelOrder"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrdersServiceCancelOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OrdersService/CancelOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrdersServiceCancelOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OrdersServiceCancelOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrdersServiceCancelOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrdersServiceGetOrderState invokes OrdersService_GetOrderState operation.
//
// Метод получения статуса торгового поручения.
//
// POST /tinkoff.public.invest.api.contract.v1.OrdersService/GetOrderState
func (c *Client) OrdersServiceGetOrderState(ctx context.Context, request *V1GetOrderStateRequest) (OrdersServiceGetOrderStateRes, error) {
	res, err := c.sendOrdersServiceGetOrderState(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOrdersServiceGetOrderState(ctx context.Context, request *V1GetOrderStateRequest) (res OrdersServiceGetOrderStateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OrdersService_GetOrderState"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrdersServiceGetOrderState",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OrdersService/GetOrderState"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrdersServiceGetOrderStateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OrdersServiceGetOrderState", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrdersServiceGetOrderStateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrdersServiceGetOrders invokes OrdersService_GetOrders operation.
//
// Метод получения списка активных заявок по счёту.
//
// POST /tinkoff.public.invest.api.contract.v1.OrdersService/GetOrders
func (c *Client) OrdersServiceGetOrders(ctx context.Context, request *V1GetOrdersRequest) (OrdersServiceGetOrdersRes, error) {
	res, err := c.sendOrdersServiceGetOrders(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOrdersServiceGetOrders(ctx context.Context, request *V1GetOrdersRequest) (res OrdersServiceGetOrdersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OrdersService_GetOrders"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrdersServiceGetOrders",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OrdersService/GetOrders"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrdersServiceGetOrdersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OrdersServiceGetOrders", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrdersServiceGetOrdersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrdersServicePostOrder invokes OrdersService_PostOrder operation.
//
// Метод выставления заявки.
//
// POST /tinkoff.public.invest.api.contract.v1.OrdersService/PostOrder
func (c *Client) OrdersServicePostOrder(ctx context.Context, request *V1PostOrderRequest) (OrdersServicePostOrderRes, error) {
	res, err := c.sendOrdersServicePostOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOrdersServicePostOrder(ctx context.Context, request *V1PostOrderRequest) (res OrdersServicePostOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OrdersService_PostOrder"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrdersServicePostOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OrdersService/PostOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrdersServicePostOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OrdersServicePostOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrdersServicePostOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrdersServiceReplaceOrder invokes OrdersService_ReplaceOrder operation.
//
// Метод изменения выставленной заявки.
//
// POST /tinkoff.public.invest.api.contract.v1.OrdersService/ReplaceOrder
func (c *Client) OrdersServiceReplaceOrder(ctx context.Context, request *V1ReplaceOrderRequest) (OrdersServiceReplaceOrderRes, error) {
	res, err := c.sendOrdersServiceReplaceOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendOrdersServiceReplaceOrder(ctx context.Context, request *V1ReplaceOrderRequest) (res OrdersServiceReplaceOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("OrdersService_ReplaceOrder"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrdersServiceReplaceOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.OrdersService/ReplaceOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrdersServiceReplaceOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "OrdersServiceReplaceOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrdersServiceReplaceOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceCancelSandboxOrder invokes SandboxService_CancelSandboxOrder operation.
//
// Метод отмены торгового поручения в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/CancelSandboxOrder
func (c *Client) SandboxServiceCancelSandboxOrder(ctx context.Context, request *V1CancelOrderRequest) (SandboxServiceCancelSandboxOrderRes, error) {
	res, err := c.sendSandboxServiceCancelSandboxOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceCancelSandboxOrder(ctx context.Context, request *V1CancelOrderRequest) (res SandboxServiceCancelSandboxOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_CancelSandboxOrder"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceCancelSandboxOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/CancelSandboxOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceCancelSandboxOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceCancelSandboxOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceCancelSandboxOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceCloseSandboxAccount invokes SandboxService_CloseSandboxAccount operation.
//
// Метод закрытия счёта в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/CloseSandboxAccount
func (c *Client) SandboxServiceCloseSandboxAccount(ctx context.Context, request *V1CloseSandboxAccountRequest) (SandboxServiceCloseSandboxAccountRes, error) {
	res, err := c.sendSandboxServiceCloseSandboxAccount(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceCloseSandboxAccount(ctx context.Context, request *V1CloseSandboxAccountRequest) (res SandboxServiceCloseSandboxAccountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_CloseSandboxAccount"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceCloseSandboxAccount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/CloseSandboxAccount"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceCloseSandboxAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceCloseSandboxAccount", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceCloseSandboxAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxAccounts invokes SandboxService_GetSandboxAccounts operation.
//
// Метод получения счетов в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxAccounts
func (c *Client) SandboxServiceGetSandboxAccounts(ctx context.Context, request *V1GetAccountsRequest) (SandboxServiceGetSandboxAccountsRes, error) {
	res, err := c.sendSandboxServiceGetSandboxAccounts(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxAccounts(ctx context.Context, request *V1GetAccountsRequest) (res SandboxServiceGetSandboxAccountsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxAccounts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxAccounts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxAccounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxAccountsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxAccounts", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxOperations invokes SandboxService_GetSandboxOperations operation.
//
// Метод получения операций в песочнице по номеру счёта.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOperations
func (c *Client) SandboxServiceGetSandboxOperations(ctx context.Context, request *V1OperationsRequest) (SandboxServiceGetSandboxOperationsRes, error) {
	res, err := c.sendSandboxServiceGetSandboxOperations(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxOperations(ctx context.Context, request *V1OperationsRequest) (res SandboxServiceGetSandboxOperationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxOperations"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxOperations",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOperations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxOperationsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxOperations", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxOperationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxOperationsByCursor invokes SandboxService_GetSandboxOperationsByCursor operation.
//
// Метод получения операций в песочнице по номеру счета
// с пагинацией.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOperationsByCursor
func (c *Client) SandboxServiceGetSandboxOperationsByCursor(ctx context.Context, request *V1GetOperationsByCursorRequest) (SandboxServiceGetSandboxOperationsByCursorRes, error) {
	res, err := c.sendSandboxServiceGetSandboxOperationsByCursor(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxOperationsByCursor(ctx context.Context, request *V1GetOperationsByCursorRequest) (res SandboxServiceGetSandboxOperationsByCursorRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxOperationsByCursor"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxOperationsByCursor",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOperationsByCursor"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxOperationsByCursorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxOperationsByCursor", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxOperationsByCursorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxOrderState invokes SandboxService_GetSandboxOrderState operation.
//
// Метод получения статуса заявки в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOrderState
func (c *Client) SandboxServiceGetSandboxOrderState(ctx context.Context, request *V1GetOrderStateRequest) (SandboxServiceGetSandboxOrderStateRes, error) {
	res, err := c.sendSandboxServiceGetSandboxOrderState(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxOrderState(ctx context.Context, request *V1GetOrderStateRequest) (res SandboxServiceGetSandboxOrderStateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxOrderState"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxOrderState",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOrderState"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxOrderStateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxOrderState", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxOrderStateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxOrders invokes SandboxService_GetSandboxOrders operation.
//
// Метод получения списка активных заявок по счёту в
// песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOrders
func (c *Client) SandboxServiceGetSandboxOrders(ctx context.Context, request *V1GetOrdersRequest) (SandboxServiceGetSandboxOrdersRes, error) {
	res, err := c.sendSandboxServiceGetSandboxOrders(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxOrders(ctx context.Context, request *V1GetOrdersRequest) (res SandboxServiceGetSandboxOrdersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxOrders"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxOrders",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxOrders"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxOrdersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxOrders", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxOrdersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxPortfolio invokes SandboxService_GetSandboxPortfolio operation.
//
// Метод получения портфолио в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxPortfolio
func (c *Client) SandboxServiceGetSandboxPortfolio(ctx context.Context, request *V1PortfolioRequest) (SandboxServiceGetSandboxPortfolioRes, error) {
	res, err := c.sendSandboxServiceGetSandboxPortfolio(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxPortfolio(ctx context.Context, request *V1PortfolioRequest) (res SandboxServiceGetSandboxPortfolioRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxPortfolio"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxPortfolio",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxPortfolio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxPortfolioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxPortfolio", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxPortfolioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxPositions invokes SandboxService_GetSandboxPositions operation.
//
// Метод получения позиций по виртуальному счёту
// песочницы.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxPositions
func (c *Client) SandboxServiceGetSandboxPositions(ctx context.Context, request *V1PositionsRequest) (SandboxServiceGetSandboxPositionsRes, error) {
	res, err := c.sendSandboxServiceGetSandboxPositions(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxPositions(ctx context.Context, request *V1PositionsRequest) (res SandboxServiceGetSandboxPositionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxPositions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxPositions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxPositions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxPositionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxPositions", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxPositionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceGetSandboxWithdrawLimits invokes SandboxService_GetSandboxWithdrawLimits operation.
//
// Метод получения доступного остатка для вывода
// средств в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxWithdrawLimits
func (c *Client) SandboxServiceGetSandboxWithdrawLimits(ctx context.Context, request *V1WithdrawLimitsRequest) (SandboxServiceGetSandboxWithdrawLimitsRes, error) {
	res, err := c.sendSandboxServiceGetSandboxWithdrawLimits(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceGetSandboxWithdrawLimits(ctx context.Context, request *V1WithdrawLimitsRequest) (res SandboxServiceGetSandboxWithdrawLimitsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_GetSandboxWithdrawLimits"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceGetSandboxWithdrawLimits",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/GetSandboxWithdrawLimits"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceGetSandboxWithdrawLimitsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceGetSandboxWithdrawLimits", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceGetSandboxWithdrawLimitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceOpenSandboxAccount invokes SandboxService_OpenSandboxAccount operation.
//
// Метод регистрации счёта в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/OpenSandboxAccount
func (c *Client) SandboxServiceOpenSandboxAccount(ctx context.Context, request *V1OpenSandboxAccountRequest) (SandboxServiceOpenSandboxAccountRes, error) {
	res, err := c.sendSandboxServiceOpenSandboxAccount(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceOpenSandboxAccount(ctx context.Context, request *V1OpenSandboxAccountRequest) (res SandboxServiceOpenSandboxAccountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_OpenSandboxAccount"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceOpenSandboxAccount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/OpenSandboxAccount"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceOpenSandboxAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceOpenSandboxAccount", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceOpenSandboxAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServicePostSandboxOrder invokes SandboxService_PostSandboxOrder operation.
//
// Метод выставления торгового поручения в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/PostSandboxOrder
func (c *Client) SandboxServicePostSandboxOrder(ctx context.Context, request *V1PostOrderRequest) (SandboxServicePostSandboxOrderRes, error) {
	res, err := c.sendSandboxServicePostSandboxOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServicePostSandboxOrder(ctx context.Context, request *V1PostOrderRequest) (res SandboxServicePostSandboxOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_PostSandboxOrder"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServicePostSandboxOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/PostSandboxOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServicePostSandboxOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServicePostSandboxOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServicePostSandboxOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceReplaceSandboxOrder invokes SandboxService_ReplaceSandboxOrder operation.
//
// Метод изменения выставленной заявки.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/ReplaceSandboxOrder
func (c *Client) SandboxServiceReplaceSandboxOrder(ctx context.Context, request *V1ReplaceOrderRequest) (SandboxServiceReplaceSandboxOrderRes, error) {
	res, err := c.sendSandboxServiceReplaceSandboxOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceReplaceSandboxOrder(ctx context.Context, request *V1ReplaceOrderRequest) (res SandboxServiceReplaceSandboxOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_ReplaceSandboxOrder"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceReplaceSandboxOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/ReplaceSandboxOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceReplaceSandboxOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceReplaceSandboxOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceReplaceSandboxOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SandboxServiceSandboxPayIn invokes SandboxService_SandboxPayIn operation.
//
// Метод пополнения счёта в песочнице.
//
// POST /tinkoff.public.invest.api.contract.v1.SandboxService/SandboxPayIn
func (c *Client) SandboxServiceSandboxPayIn(ctx context.Context, request *V1SandboxPayInRequest) (SandboxServiceSandboxPayInRes, error) {
	res, err := c.sendSandboxServiceSandboxPayIn(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendSandboxServiceSandboxPayIn(ctx context.Context, request *V1SandboxPayInRequest) (res SandboxServiceSandboxPayInRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SandboxService_SandboxPayIn"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SandboxServiceSandboxPayIn",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.SandboxService/SandboxPayIn"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSandboxServiceSandboxPayInRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "SandboxServiceSandboxPayIn", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSandboxServiceSandboxPayInResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopOrdersServiceCancelStopOrder invokes StopOrdersService_CancelStopOrder operation.
//
// Метод отмены стоп-заявки.
//
// POST /tinkoff.public.invest.api.contract.v1.StopOrdersService/CancelStopOrder
func (c *Client) StopOrdersServiceCancelStopOrder(ctx context.Context, request *V1CancelStopOrderRequest) (StopOrdersServiceCancelStopOrderRes, error) {
	res, err := c.sendStopOrdersServiceCancelStopOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendStopOrdersServiceCancelStopOrder(ctx context.Context, request *V1CancelStopOrderRequest) (res StopOrdersServiceCancelStopOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("StopOrdersService_CancelStopOrder"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StopOrdersServiceCancelStopOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.StopOrdersService/CancelStopOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopOrdersServiceCancelStopOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "StopOrdersServiceCancelStopOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStopOrdersServiceCancelStopOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopOrdersServiceGetStopOrders invokes StopOrdersService_GetStopOrders operation.
//
// Метод получения списка активных стоп заявок по счёту.
//
// POST /tinkoff.public.invest.api.contract.v1.StopOrdersService/GetStopOrders
func (c *Client) StopOrdersServiceGetStopOrders(ctx context.Context, request *V1GetStopOrdersRequest) (StopOrdersServiceGetStopOrdersRes, error) {
	res, err := c.sendStopOrdersServiceGetStopOrders(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendStopOrdersServiceGetStopOrders(ctx context.Context, request *V1GetStopOrdersRequest) (res StopOrdersServiceGetStopOrdersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("StopOrdersService_GetStopOrders"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StopOrdersServiceGetStopOrders",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.StopOrdersService/GetStopOrders"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopOrdersServiceGetStopOrdersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "StopOrdersServiceGetStopOrders", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStopOrdersServiceGetStopOrdersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StopOrdersServicePostStopOrder invokes StopOrdersService_PostStopOrder operation.
//
// Метод выставления стоп-заявки.
//
// POST /tinkoff.public.invest.api.contract.v1.StopOrdersService/PostStopOrder
func (c *Client) StopOrdersServicePostStopOrder(ctx context.Context, request *V1PostStopOrderRequest) (StopOrdersServicePostStopOrderRes, error) {
	res, err := c.sendStopOrdersServicePostStopOrder(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendStopOrdersServicePostStopOrder(ctx context.Context, request *V1PostStopOrderRequest) (res StopOrdersServicePostStopOrderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("StopOrdersService_PostStopOrder"),
	}
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "StopOrdersServicePostStopOrder",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.StopOrdersService/PostStopOrder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStopOrdersServicePostStopOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "StopOrdersServicePostStopOrder", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStopOrdersServicePostStopOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersServiceGetAccounts invokes UsersService_GetAccounts operation.
//
// Метод получения счетов пользователя.
//
// POST /tinkoff.public.invest.api.contract.v1.UsersService/GetAccounts
func (c *Client) UsersServiceGetAccounts(ctx context.Context, request *V1GetAccountsRequest) (UsersServiceGetAccountsRes, error) {
	res, err := c.sendUsersServiceGetAccounts(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendUsersServiceGetAccounts(ctx context.Context, request *V1GetAccountsRequest) (res UsersServiceGetAccountsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersService_GetAccounts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersServiceGetAccounts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.UsersService/GetAccounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersServiceGetAccountsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "UsersServiceGetAccounts", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersServiceGetAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersServiceGetInfo invokes UsersService_GetInfo operation.
//
// Метод получения информации о пользователе.
//
// POST /tinkoff.public.invest.api.contract.v1.UsersService/GetInfo
func (c *Client) UsersServiceGetInfo(ctx context.Context, request *V1GetInfoRequest) (UsersServiceGetInfoRes, error) {
	res, err := c.sendUsersServiceGetInfo(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendUsersServiceGetInfo(ctx context.Context, request *V1GetInfoRequest) (res UsersServiceGetInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersService_GetInfo"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersServiceGetInfo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.UsersService/GetInfo"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersServiceGetInfoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "UsersServiceGetInfo", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersServiceGetInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersServiceGetMarginAttributes invokes UsersService_GetMarginAttributes operation.
//
// Расчёт маржинальных показателей по счёту.
//
// POST /tinkoff.public.invest.api.contract.v1.UsersService/GetMarginAttributes
func (c *Client) UsersServiceGetMarginAttributes(ctx context.Context, request *V1GetMarginAttributesRequest) (UsersServiceGetMarginAttributesRes, error) {
	res, err := c.sendUsersServiceGetMarginAttributes(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendUsersServiceGetMarginAttributes(ctx context.Context, request *V1GetMarginAttributesRequest) (res UsersServiceGetMarginAttributesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersService_GetMarginAttributes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersServiceGetMarginAttributes",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.UsersService/GetMarginAttributes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersServiceGetMarginAttributesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "UsersServiceGetMarginAttributes", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersServiceGetMarginAttributesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersServiceGetUserTariff invokes UsersService_GetUserTariff operation.
//
// Запрос тарифа пользователя.
//
// POST /tinkoff.public.invest.api.contract.v1.UsersService/GetUserTariff
func (c *Client) UsersServiceGetUserTariff(ctx context.Context, request *V1GetUserTariffRequest) (UsersServiceGetUserTariffRes, error) {
	res, err := c.sendUsersServiceGetUserTariff(ctx, request)
	_ = res
	return res, err
}

func (c *Client) sendUsersServiceGetUserTariff(ctx context.Context, request *V1GetUserTariffRequest) (res UsersServiceGetUserTariffRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersService_GetUserTariff"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, elapsedDuration.Microseconds(), otelAttrs...)
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, otelAttrs...)

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UsersServiceGetUserTariff",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, otelAttrs...)
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tinkoff.public.invest.api.contract.v1.UsersService/GetUserTariff"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u, nil)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersServiceGetUserTariffRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Bearer"
			switch err := c.securityBearer(ctx, "UsersServiceGetUserTariff", r); err {
			case nil:
				satisfied[0] |= 1 << 0
			case ogenerrors.ErrSkipClientSecurity:
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, errors.New("no security requirement satisfied")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsersServiceGetUserTariffResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
